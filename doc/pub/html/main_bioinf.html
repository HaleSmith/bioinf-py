

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Illustrating Python via Bioinformatics Examples</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.9',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>
    <link rel="top" title="Illustrating Python via Examples from Bioinformatics" href="index.html" />
    <link rel="prev" title="Illustrating Python via Examples from Bioinformatics" href="index.html" /> 
  
   <style type=text/css>
     div.admonition {
       background-color: whiteSmoke;
       border: 1px solid #bababa;
     }
   </style>
  </head>

  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="index.html" title="Illustrating Python via Examples from Bioinformatics"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Illustrating Python via Examples from Bioinformatics</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="illustrating-python-via-bioinformatics-examples">
<h1>Illustrating Python via Bioinformatics Examples<a class="headerlink" href="#illustrating-python-via-bioinformatics-examples" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Hans Petter Langtangen, Geir Kjetil Sandve</td>
</tr>
<tr class="field-even field"><th class="field-name">Date:</th><td class="field-body">May 8, 2014</td>
</tr>
</tbody>
</table>
<span class="target" id="index-0"></span><p id="index-1">Life is definitely digital. The genetic code of all living organisms
are represented by a long sequence of simple molecules called
nucleotides, or bases, which makes up the Deoxyribonucleic acid,
better known as DNA. There are only four such nucleotides, and the
entire genetic code of a human can be seen as a simple, though 3
billion long, string of the letters A, C, G, and T.  Analyzing DNA
data to gain increased biological understanding is much about
searching in (long) strings for certain string patterns involving the
letters A, C, G, and T.  This is an integral part of <em>bioinformatics</em>,
a scientific discipline addressing the use of computers to search
for, explore, and use information about genes, nucleic acids, and
proteins.</p>
</div>
<div class="section" id="basic-bioinformatics-examples-in-python">
<h1>Basic Bioinformatics Examples in Python<a class="headerlink" href="#basic-bioinformatics-examples-in-python" title="Permalink to this headline">¶</a></h1>
<p>The leading Python software for bioinformatics applications is
<a class="reference external" href="http://biopython.org">BioPython</a>. The forthcoming examples are
simple illustrations of the type of problem settings and corresponding
Python implementations that are encountered in bioinformatics. For
real-world problem solving one should rather utilize BioPython, but
the sections below acts as an introduction to what is inside packages
like BioPython.</p>
<p>We start with some very simple examples on DNA analysis that bring together
basic building blocks in programming: loops, <tt class="docutils literal"><span class="pre">if</span></tt> tests, and functions.</p>
<div class="section" id="counting-letters-in-dna-strings">
<span id="bioinf-count"></span><h2>Counting Letters in DNA Strings<a class="headerlink" href="#counting-letters-in-dna-strings" title="Permalink to this headline">¶</a></h2>
<p>Given some string <tt class="docutils literal"><span class="pre">dna</span></tt> containing the letters A, C, G, or T,
representing the bases that make up DNA, we ask the question: how
many times does a certain base occur in the DNA string?
For example, if <tt class="docutils literal"><span class="pre">dna</span></tt> is ATGGCATTA and we ask how many times the
base A occur in this string, the answer is 3.</p>
<p>A general Python implementation answering this problem can be done
in many ways. Several possible solutions are presented below.</p>
<div class="section" id="list-iteration">
<h3>List Iteration<a class="headerlink" href="#list-iteration" title="Permalink to this headline">¶</a></h3>
<p id="index-2">The most straightforward solution is to loop over the letters
in the string, test if the current letter equals the desired one,
and if so, increase a counter. Looping over the letters is
obvious if the letters are stored in a list. This is easily
done by converting a string to a list:</p>
<div class="highlight-text"><div class="highlight"><pre>&gt;&gt;&gt; list(&#39;ATGC&#39;)
[&#39;A&#39;, &#39;T&#39;, &#39;G&#39;, &#39;C&#39;]
</pre></div>
</div>
<p>Our first solution becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">count_v1</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
    <span class="n">dna</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dna</span><span class="p">)</span>  <span class="c"># convert string to list of letters</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>            <span class="c"># counter</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">dna</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="n">base</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">i</span>
</pre></div>
</div>
</div>
<div class="section" id="string-iteration">
<h3>String Iteration<a class="headerlink" href="#string-iteration" title="Permalink to this headline">¶</a></h3>
<p id="index-3">Python allows us to iterate directly over a string without converting
it to a list:</p>
<div class="highlight-text"><div class="highlight"><pre>&gt;&gt;&gt; for c in &#39;ATGC&#39;:
...     print c
A
T
G
C
</pre></div>
</div>
<p>In fact, all built-in objects in Python that contain a set of elements in
a particular sequence allow a <tt class="docutils literal"><span class="pre">for</span></tt> loop construction of the
type <tt class="docutils literal"><span class="pre">for</span> <span class="pre">element</span> <span class="pre">in</span> <span class="pre">object</span></tt>.</p>
<p>A slight improvement of our solution is therefore to iterate directly
over the string:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">count_v2</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="c"># counter</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">dna</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="n">base</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">i</span>

<span class="n">dna</span> <span class="o">=</span> <span class="s">&#39;ATGCGGACCTAT&#39;</span>
<span class="n">base</span> <span class="o">=</span> <span class="s">&#39;C&#39;</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">count_v2</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>

<span class="c"># printf-style formatting</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s"> appears </span><span class="si">%d</span><span class="s"> times in </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">dna</span><span class="p">)</span>

<span class="c"># or (new) format string syntax</span>
<span class="k">print</span> <span class="s">&#39;{base} appears {n} times in {dna}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
    <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">dna</span><span class="o">=</span><span class="n">dna</span><span class="p">)</span>
</pre></div>
</div>
<p>We have here illustrated two alternative ways of writing out text
where the value of variables are to be inserted in &#8220;slots&#8221; in the
string.</p>
</div>
<div class="section" id="program-flow">
<h3>Program Flow<a class="headerlink" href="#program-flow" title="Permalink to this headline">¶</a></h3>
<p>It is fundamental for correct programming to understand how
to simulate a program by hand, statement by
statement. Three tools are
effective for helping you reach the required understanding of performing
a simulation by hand:</p>
<ol class="arabic simple">
<li>printing variables and messages,</li>
<li>using a debugger,</li>
<li>using the <a class="reference external" href="http://www.pythontutor.com/">Online Python Tutor</a>.</li>
</ol>
<p>Inserting <tt class="docutils literal"><span class="pre">print</span></tt> statements and examining the variables is the
simplest approach to investigating
what is going on:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">count_v2_demo</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">&#39;dna:&#39;</span><span class="p">,</span> <span class="n">dna</span>
    <span class="k">print</span> <span class="s">&#39;base:&#39;</span><span class="p">,</span> <span class="n">base</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="c"># counter</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">dna</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;c:&#39;</span><span class="p">,</span> <span class="n">c</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="n">base</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;True if test&#39;</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">i</span>

<span class="n">n</span> <span class="o">=</span> <span class="n">count_v2_demo</span><span class="p">(</span><span class="s">&#39;ATGCGGACCTAT&#39;</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">)</span>
</pre></div>
</div>
<span class="target" id="index-4"></span><p>An efficient way to explore this program is to run it in a
debugger where we can step through each statement and see what
is printed out. Start <tt class="docutils literal"><span class="pre">ipython</span></tt> in a terminal window and run the
program <a class="reference external" href="http://tinyurl.com/q4qpjbt/count_v2_demo.py">count_v2_demo.py</a> with
a debugger: <tt class="docutils literal"><span class="pre">run</span> <span class="pre">-d</span> <span class="pre">count_v2_demo.py</span></tt>. Use <tt class="docutils literal"><span class="pre">s</span></tt> (for step) to
step through each statement, or <tt class="docutils literal"><span class="pre">n</span></tt> (for next) for proceeding to the
next statement without stepping through a function that is called.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ipdb</span><span class="o">&gt;</span> <span class="n">s</span>
<span class="o">&gt;</span> <span class="o">/</span><span class="n">some</span><span class="o">/</span><span class="n">disk</span><span class="o">/</span><span class="n">user</span><span class="o">/</span><span class="n">bioinf</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">count_v2_demo</span><span class="o">.</span><span class="n">py</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="n">count_v2_demo</span><span class="p">()</span>
<span class="mi">1</span>     <span class="mi">1</span> <span class="k">def</span> <span class="nf">count_v1_demo</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
<span class="o">----&gt;</span> <span class="mi">2</span>     <span class="k">print</span> <span class="s">&#39;dna:&#39;</span><span class="p">,</span> <span class="n">dna</span>
      <span class="mi">3</span>     <span class="k">print</span> <span class="s">&#39;base:&#39;</span><span class="p">,</span> <span class="n">base</span>

<span class="n">ipdb</span><span class="o">&gt;</span> <span class="n">s</span>
<span class="n">dna</span><span class="p">:</span> <span class="n">ATGCGGACCTAT</span>
<span class="o">&gt;</span> <span class="o">/</span><span class="n">some</span><span class="o">/</span><span class="n">disk</span><span class="o">/</span><span class="n">user</span><span class="o">/</span><span class="n">bioinf</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">count_v2_demo</span><span class="o">.</span><span class="n">py</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="n">count_v2_demo</span><span class="p">()</span>
      <span class="mi">2</span>     <span class="k">print</span> <span class="s">&#39;dna:&#39;</span><span class="p">,</span> <span class="n">dna</span>
<span class="o">----&gt;</span> <span class="mi">3</span>     <span class="k">print</span> <span class="s">&#39;base:&#39;</span><span class="p">,</span> <span class="n">base</span>
      <span class="mi">4</span>     <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="c"># counter</span>
</pre></div>
</div>
<p>Observe the output of the <tt class="docutils literal"><span class="pre">print</span></tt> statements. One can also
print a variable explicitly inside the debugger:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ipdb</span><span class="o">&gt;</span> <span class="k">print</span> <span class="n">base</span>
<span class="n">C</span>
</pre></div>
</div>
<p>The <a class="reference external" href="http://www.pythontutor.com/">Online Python Tutor</a>
is, at least for small programs, a splendid alternative to
debuggers. Go to the web page, erase the sample code and paste in your
own code. Press <em>Visual execution</em>, then <em>Forward</em> to execute
statements one by one. The status of variables are
explained to the right, and the text field below the program shows the output
from <tt class="docutils literal"><span class="pre">print</span></tt> statements.  An example is shown in Figure <a class="reference internal" href="#bioinf-fig-pot"><em>Visual execution of a program using the Online Python Tutor</em></a>.</p>
<div class="figure" id="bioinf-fig-pot">
<img alt="_images/python_online_tutor.jpg" src="_images/python_online_tutor.jpg" style="width: 600px;" />
<p class="caption"><em>Visual execution of a program using the Online Python Tutor</em></p>
</div>
<p>Misunderstanding of the program flow is one of the most frequent
sources of programming errors, so whenever in doubt about any program
flow, use one of the three mentioned techniques to establish
confidence!</p>
</div>
<div class="section" id="index-iteration">
<h3>Index Iteration<a class="headerlink" href="#index-iteration" title="Permalink to this headline">¶</a></h3>
<p>Although it is natural in Python to iterate over the letters in a
string (or more generally over elements in a sequence), programmers
with experience from other languages (Fortran, C and Java are
examples) are used to <tt class="docutils literal"><span class="pre">for</span></tt> loops with an integer counter running over
all indices in a string or array:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">count_v3</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="c"># counter</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dna</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">dna</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">base</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">i</span>
</pre></div>
</div>
<p>Python indices always start at 0 so the legal indices for our
string become <tt class="docutils literal"><span class="pre">0</span></tt>, <tt class="docutils literal"><span class="pre">1</span></tt>, ...,
<tt class="docutils literal"><span class="pre">len(dna)-1</span></tt>, where <tt class="docutils literal"><span class="pre">len(dna)</span></tt> is the number of letters in the
string <tt class="docutils literal"><span class="pre">dna</span></tt>. The <tt class="docutils literal"><span class="pre">range(x)</span></tt> function returns a list of integers
<tt class="docutils literal"><span class="pre">0</span></tt>, <tt class="docutils literal"><span class="pre">1</span></tt>, ..., <tt class="docutils literal"><span class="pre">x-1</span></tt>, implying that <tt class="docutils literal"><span class="pre">range(len(dna))</span></tt> generates
all the legal indices for <tt class="docutils literal"><span class="pre">dna</span></tt>.</p>
</div>
<div class="section" id="while-loops">
<h3>While Loops<a class="headerlink" href="#while-loops" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">while</span></tt> loop equivalent to the last function reads</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">count_v4</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="c"># counter</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="c"># string index</span>
    <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">dna</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dna</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">base</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">i</span>
</pre></div>
</div>
<p>Correct indentation is here crucial: a typical error is to fail
indenting the <tt class="docutils literal"><span class="pre">j</span> <span class="pre">+=</span> <span class="pre">1</span></tt> line correctly.</p>
</div>
<div class="section" id="summing-a-boolean-list">
<h3>Summing a Boolean List<a class="headerlink" href="#summing-a-boolean-list" title="Permalink to this headline">¶</a></h3>
<p>The idea now is to create a list <tt class="docutils literal"><span class="pre">m</span></tt> where <tt class="docutils literal"><span class="pre">m[i]</span></tt> is <tt class="docutils literal"><span class="pre">True</span></tt> if
<tt class="docutils literal"><span class="pre">dna[i]</span></tt> equals the letter we search for (<tt class="docutils literal"><span class="pre">base</span></tt>).
The number of <tt class="docutils literal"><span class="pre">True</span></tt> values in <tt class="docutils literal"><span class="pre">m</span></tt> is then the number of <tt class="docutils literal"><span class="pre">base</span></tt>
letters in <tt class="docutils literal"><span class="pre">dna</span></tt>. We can use the <tt class="docutils literal"><span class="pre">sum</span></tt> function to find
this number because doing arithmetics with boolean lists
automatically interprets <tt class="docutils literal"><span class="pre">True</span></tt> as <tt class="docutils literal"><span class="pre">1</span></tt> and <tt class="docutils literal"><span class="pre">False</span></tt> as <tt class="docutils literal"><span class="pre">0</span></tt>.
That is, <tt class="docutils literal"><span class="pre">sum(m)</span></tt> returns the number of <tt class="docutils literal"><span class="pre">True</span></tt> elements in <tt class="docutils literal"><span class="pre">m</span></tt>.
A possible function doing this is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">count_v5</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
    <span class="n">m</span> <span class="o">=</span> <span class="p">[]</span>   <span class="c"># matches for base in dna: m[i]=True if dna[i]==base</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">dna</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="n">base</span><span class="p">:</span>
            <span class="n">m</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">m</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="inline-if-test">
<h3>Inline If Test<a class="headerlink" href="#inline-if-test" title="Permalink to this headline">¶</a></h3>
<p>Shorter, more compact code is often a goal if the compactness
enhances readability. The four-line <tt class="docutils literal"><span class="pre">if</span></tt> test in the previous
function can be condensed to one line using the inline
<tt class="docutils literal"><span class="pre">if</span></tt> construction: <tt class="docutils literal"><span class="pre">if</span> <span class="pre">condition</span> <span class="pre">value1</span> <span class="pre">else</span> <span class="pre">value2</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">count_v6</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
    <span class="n">m</span> <span class="o">=</span> <span class="p">[]</span>   <span class="c"># matches for base in dna: m[i]=True if dna[i]==base</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">dna</span><span class="p">:</span>
        <span class="n">m</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">True</span> <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="n">base</span> <span class="k">else</span> <span class="bp">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="using-boolean-values-directly">
<h3>Using Boolean Values Directly<a class="headerlink" href="#using-boolean-values-directly" title="Permalink to this headline">¶</a></h3>
<p>The inline <tt class="docutils literal"><span class="pre">if</span></tt> test is in fact redundant in the previous function
because the value of the condition <tt class="docutils literal"><span class="pre">c</span> <span class="pre">==</span> <span class="pre">base</span></tt> can be used
directly: it has the value <tt class="docutils literal"><span class="pre">True</span></tt> or <tt class="docutils literal"><span class="pre">False</span></tt>. This saves
some typing and adds clarity, at least to Python programmers with
some experience:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">count_v7</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
    <span class="n">m</span> <span class="o">=</span> <span class="p">[]</span>   <span class="c"># matches for base in dna: m[i]=True if dna[i]==base</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">dna</span><span class="p">:</span>
        <span class="n">m</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">base</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="list-comprehensions">
<h3>List Comprehensions<a class="headerlink" href="#list-comprehensions" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-6"></span><p id="index-7">Building a list with the aid of a <tt class="docutils literal"><span class="pre">for</span></tt> loop can often be condensed to
a single line by using list comprehensions: <tt class="docutils literal"><span class="pre">[expr</span> <span class="pre">for</span> <span class="pre">e</span> <span class="pre">in</span>
<span class="pre">sequence]</span></tt>, where <tt class="docutils literal"><span class="pre">expr</span></tt> is some expression normally involving the
iteration variable <tt class="docutils literal"><span class="pre">e</span></tt>. In our last example, we can introduce a list
comprehension</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">count_v8</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
    <span class="n">m</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="o">==</span> <span class="n">base</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">dna</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>Here it is tempting to get rid of the <tt class="docutils literal"><span class="pre">m</span></tt> variable and
reduce the function body to a single line:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">count_v9</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="n">c</span> <span class="o">==</span> <span class="n">base</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">dna</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="using-a-sum-iterator">
<h3>Using a Sum Iterator<a class="headerlink" href="#using-a-sum-iterator" title="Permalink to this headline">¶</a></h3>
<p id="index-8">The DNA string is usually huge - 3 billion letters for the human
species. Making a boolean array with <tt class="docutils literal"><span class="pre">True</span></tt> and <tt class="docutils literal"><span class="pre">False</span></tt> values
therefore increases the memory usage by a factor of two
in our sample functions <tt class="docutils literal"><span class="pre">count_v5</span></tt> to <tt class="docutils literal"><span class="pre">count_v9</span></tt>.
Summing without actually storing an extra list is desirable.
Fortunately, <tt class="docutils literal"><span class="pre">sum([x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">s])</span></tt> can be replaced by
<tt class="docutils literal"><span class="pre">sum(x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">s)</span></tt>, where the latter sums the elements in <tt class="docutils literal"><span class="pre">s</span></tt>
as <tt class="docutils literal"><span class="pre">x</span></tt> visits the elements of <tt class="docutils literal"><span class="pre">s</span></tt> one by one. Removing the brackets
therefore avoids first making a list before applying <tt class="docutils literal"><span class="pre">sum</span></tt> to
that list. This is a minor modification of the <tt class="docutils literal"><span class="pre">count_v9</span></tt> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">count_v10</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">base</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">dna</span><span class="p">)</span>
</pre></div>
</div>
<p>Below we shall measure the impact of the various program constructs
on the CPU time.</p>
</div>
<div class="section" id="extracting-indices">
<h3>Extracting Indices<a class="headerlink" href="#extracting-indices" title="Permalink to this headline">¶</a></h3>
<p>Instead of making a boolean list with elements expressing whether
a letter matches the given <tt class="docutils literal"><span class="pre">base</span></tt> or not, we may collect all
the indices of the matches. This can be done by adding an <tt class="docutils literal"><span class="pre">if</span></tt>
test to the list comprehension:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">count_v11</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dna</span><span class="p">))</span> <span class="k">if</span> <span class="n">dna</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">base</span><span class="p">])</span>
</pre></div>
</div>
<p>The <a class="reference external" href="http://www.pythontutor.com/">Online Python Tutor</a> is
really helpful to reach an understanding of this compact code.
Alternatively, you may play with the constructions in an
interactive Python shell:</p>
<div class="highlight-text"><div class="highlight"><pre>&gt;&gt;&gt; dna = &#39;AATGCTTA&#39;
&gt;&gt;&gt; base = &#39;A&#39;
&gt;&gt;&gt; indices = [i for i in range(len(dna)) if dna[i] == base]
&gt;&gt;&gt; indices
[0, 1, 7]
&gt;&gt;&gt; print dna[0], dna[1], dna[7]  # check
A A A
</pre></div>
</div>
<p>Observe that the element <tt class="docutils literal"><span class="pre">i</span></tt> in the list comprehension is only
made for those <tt class="docutils literal"><span class="pre">i</span></tt>
where <tt class="docutils literal"><span class="pre">dna[i]</span> <span class="pre">==</span> <span class="pre">base</span></tt>.</p>
</div>
<div class="section" id="using-python-s-library">
<h3>Using Python&#8217;s Library<a class="headerlink" href="#using-python-s-library" title="Permalink to this headline">¶</a></h3>
<p>Very often when you set out to do a task in Python, there is already
functionality for the task in the object itself, in the Python
libraries, or in third-party libraries found on the Internet.
Counting how many times a letter (or substring) <tt class="docutils literal"><span class="pre">base</span></tt> appears in a
string <tt class="docutils literal"><span class="pre">dna</span></tt> is obviously a very common task so Python supports
it by the syntax <tt class="docutils literal"><span class="pre">dna.count(base)</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">count_v12</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">dna</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">compare_efficiency</span><span class="p">():</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="efficiency-assessment">
<span id="bioinf-count-cpu"></span><h2>Efficiency Assessment<a class="headerlink" href="#efficiency-assessment" title="Permalink to this headline">¶</a></h2>
<p>Now we have 11 different versions of how to count the occurrences
of a letter in a string. Which one of these implementations is the fastest?
To answer the question we need some test data, which should be a
huge string <tt class="docutils literal"><span class="pre">dna</span></tt>.</p>
<div class="section" id="generating-random-dna-strings">
<h3>Generating Random DNA Strings<a class="headerlink" href="#generating-random-dna-strings" title="Permalink to this headline">¶</a></h3>
<p id="index-9">The simplest way of generating a long string is to repeat a
character a large number of times:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">N</span> <span class="o">=</span> <span class="mi">1000000</span>
<span class="n">dna</span> <span class="o">=</span> <span class="s">&#39;A&#39;</span><span class="o">*</span><span class="n">N</span>
</pre></div>
</div>
<p>The resulting string is just <tt class="docutils literal"><span class="pre">'AAA...A</span></tt>, of length <tt class="docutils literal"><span class="pre">N</span></tt>, which is fine
for testing the efficiency of Python functions. Nevertheless, it is
more exciting to work with a DNA string with letters from the whole
alphabet A, C, G, and T. To make a DNA string with a random
composition of the letters we can first make a list of random
letters and then join all those letters to a string:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">random</span>
<span class="n">alphabet</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="s">&#39;ATGC&#39;</span><span class="p">)</span>
<span class="n">dna</span> <span class="o">=</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">alphabet</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
<span class="n">dna</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dna</span><span class="p">)</span>  <span class="c"># join the list elements to a string</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">random.choice(x)</span></tt> function selects an element in the list
<tt class="docutils literal"><span class="pre">x</span></tt> at random.</p>
<p>Note that <tt class="docutils literal"><span class="pre">N</span></tt> is very often a large number. In Python version 2.x,
<tt class="docutils literal"><span class="pre">range(N)</span></tt> generates a list of <tt class="docutils literal"><span class="pre">N</span></tt> integers. We can avoid the list by
using <tt class="docutils literal"><span class="pre">xrange</span></tt> which generates an integer at a time and not the whole
list. In Python version 3.x, the <tt class="docutils literal"><span class="pre">range</span></tt> function is actually the
<tt class="docutils literal"><span class="pre">xrange</span></tt> function in version 2.x.  Using <tt class="docutils literal"><span class="pre">xrange</span></tt>, combining the
statements, and wrapping the construction of a random DNA string in a
function, gives</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">random</span>

<span class="k">def</span> <span class="nf">generate_string</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">alphabet</span><span class="o">=</span><span class="s">&#39;ACGT&#39;</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">alphabet</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">N</span><span class="p">)])</span>

<span class="n">dna</span> <span class="o">=</span> <span class="n">generate_string</span><span class="p">(</span><span class="mi">600000</span><span class="p">)</span>
</pre></div>
</div>
<p>The call <tt class="docutils literal"><span class="pre">generate_string(10)</span></tt> may generate something like <tt class="docutils literal"><span class="pre">AATGGCAGAA</span></tt>.</p>
</div>
<div class="section" id="measuring-cpu-time">
<h3>Measuring CPU Time<a class="headerlink" href="#measuring-cpu-time" title="Permalink to this headline">¶</a></h3>
<p id="index-10">Our next goal is to see how much time the various <tt class="docutils literal"><span class="pre">count_v*</span></tt>
functions spend on counting letters in a huge string, which is to be
generated as shown above.
Measuring the time spent in a program can be done by the <tt class="docutils literal"><span class="pre">time</span></tt>
module:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">time</span>
<span class="o">...</span>
<span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
<span class="c"># do stuff</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
<span class="n">cpu_time</span> <span class="o">=</span> <span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">time.clock()</span></tt> function returns the CPU time spent in the program since
its start. If the interest is in the total time, also including reading
and writing files, <tt class="docutils literal"><span class="pre">time.time()</span></tt> is the appropriate function to call.</p>
<p>Running through all our functions made so far and recording timings can be
done by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">time</span>
<span class="n">functions</span> <span class="o">=</span> <span class="p">[</span><span class="n">count_v1</span><span class="p">,</span> <span class="n">count_v2</span><span class="p">,</span> <span class="n">count_v3</span><span class="p">,</span> <span class="n">count_v4</span><span class="p">,</span>
             <span class="n">count_v5</span><span class="p">,</span> <span class="n">count_v6</span><span class="p">,</span> <span class="n">count_v7</span><span class="p">,</span> <span class="n">count_v8</span><span class="p">,</span>
             <span class="n">count_v9</span><span class="p">,</span> <span class="n">count_v10</span><span class="p">,</span> <span class="n">count_v11</span><span class="p">,</span> <span class="n">count_v12</span><span class="p">]</span>
<span class="n">timings</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># timings[i] holds CPU time for functions[i]</span>

<span class="k">for</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">functions</span><span class="p">:</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
    <span class="n">function</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">)</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
    <span class="n">cpu_time</span> <span class="o">=</span> <span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span>
    <span class="n">timings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cpu_time</span><span class="p">)</span>
</pre></div>
</div>
<p>In Python, functions are ordinary objects so making a list of
functions is no more special than making a list of strings or numbers.</p>
<p>We can now iterate over <tt class="docutils literal"><span class="pre">timings</span></tt> and <tt class="docutils literal"><span class="pre">functions</span></tt> simultaneously via <tt class="docutils literal"><span class="pre">zip</span></tt>
to make a nice printout of the results:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">cpu_time</span><span class="p">,</span> <span class="n">function</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">timings</span><span class="p">,</span> <span class="n">functions</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">&#39;{f:&lt;9s}: {cpu:.2f} s&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">f</span><span class="o">=</span><span class="n">function</span><span class="o">.</span><span class="n">func_name</span><span class="p">,</span> <span class="n">cpu</span><span class="o">=</span><span class="n">cpu_time</span><span class="p">)</span>
</pre></div>
</div>
<p>Timings on a MacBook Air 11 running Ubuntu show that
the functions using <tt class="docutils literal"><span class="pre">list.append</span></tt> require almost the double of
the time of the functions that work with list comprehensions.
Even faster is the simple iteration over the string.
However, the built-in count functionality of strings
(<tt class="docutils literal"><span class="pre">dna.count(base)</span></tt>) runs over 30 times faster than the best of our
handwritten Python functions!
The reason is that the <tt class="docutils literal"><span class="pre">for</span></tt> loop needed to count in <tt class="docutils literal"><span class="pre">dna.count(base)</span></tt>
is actually implemented in C and runs very much faster than loops in Python.</p>
<p>A clear lesson learned is: google around before you start out to implement
what seems to be a quite common task. Others have probably already
done it for you, and most likely is their solution much better than what
you can (easily) come up with.</p>
</div>
</div>
<div class="section" id="verifying-the-implementations">
<span id="bioinf-count-verify"></span><h2>Verifying the implementations<a class="headerlink" href="#verifying-the-implementations" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-11"></span><span class="target" id="index-12"></span><span class="target" id="index-13"></span><span class="target" id="index-14"></span><p id="index-15">We end this section with showing how to make tests that verify our 12
counting functions. To this end, we make a new function that first
computes a certainly correct answer to a counting problem and then
calls all the <tt class="docutils literal"><span class="pre">count_*</span></tt> functions, stored in the list <tt class="docutils literal"><span class="pre">functions</span></tt>, to
check that each call has the correct result:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_count_all</span><span class="p">():</span>
    <span class="n">dna</span> <span class="o">=</span> <span class="s">&#39;ATTTGCGGTCCAAA&#39;</span>
    <span class="n">exact</span> <span class="o">=</span> <span class="n">dna</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">functions</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">f</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">)</span> <span class="o">!=</span> <span class="n">exact</span><span class="p">:</span>
            <span class="k">print</span> <span class="n">f</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="s">&#39;failed&#39;</span>
</pre></div>
</div>
<p>Here, we believe in <tt class="docutils literal"><span class="pre">dna.count('A')</span></tt> as the correct answer.</p>
<p>We might take this test function one step further and adopt the
conventions in the <a class="reference external" href="http://pytest.org">pytest</a> and
<a class="reference external" href="https://nose.readthedocs.org">nose</a>
testing frameworks for Python code.</p>
<p>These conventions say that the test function should</p>
<blockquote>
<div><ul class="simple">
<li>have a name starting with <tt class="docutils literal"><span class="pre">test_</span></tt>;</li>
<li>have no arguments;</li>
<li>let a boolean variable, say <tt class="docutils literal"><span class="pre">success</span></tt>, be <tt class="docutils literal"><span class="pre">True</span></tt> if a test
passes and be <tt class="docutils literal"><span class="pre">False</span></tt> if the test fails;</li>
<li>create a message about what failed, stored in some string, say <tt class="docutils literal"><span class="pre">msg</span></tt>;</li>
<li>use the construction <tt class="docutils literal"><span class="pre">assert</span> <span class="pre">success,</span> <span class="pre">msg</span></tt>, which will
abort the program and write out the error message
<tt class="docutils literal"><span class="pre">msg</span></tt> if <tt class="docutils literal"><span class="pre">success</span></tt> is <tt class="docutils literal"><span class="pre">False</span></tt>.</li>
</ul>
</div></blockquote>
<p id="index-16">The pytest and nose test frameworks can search for all Python files in
a folder tree, run all <tt class="docutils literal"><span class="pre">test_*()</span></tt> functions, and report how many of
the tests that failed, if we adopt the conventions above.  Our revised
test function becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_count_all</span><span class="p">():</span>
    <span class="n">dna</span> <span class="o">=</span> <span class="s">&#39;ATTTGCGGTCCAAA&#39;</span>
    <span class="n">exact</span> <span class="o">=</span> <span class="n">dna</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">functions</span><span class="p">:</span>
        <span class="n">success</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">exact</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s"> failed&#39;</span> <span class="o">%</span> <span class="n">f</span><span class="o">.</span><span class="n">__name__</span>
        <span class="k">assert</span> <span class="n">success</span><span class="p">,</span> <span class="n">msg</span>
</pre></div>
</div>
<p>It is worth notifying that the name of a function <tt class="docutils literal"><span class="pre">f</span></tt>, as a string object,
is given by <tt class="docutils literal"><span class="pre">f.__name__</span></tt>, and we make use of this information to
construct an informative message in case a test fails.</p>
<p>It is a good habit to write such test functions since the execution
of all tests in all files can be fully automated. Every time you to
a change in some file you can with minimum effort rerun all tests.</p>
<p>The entire suite of functions presented above, including the timings and tests,
can be found in the file <a class="reference external" href="http://tinyurl.com/q4qpjbt/count.py">count.py</a>.</p>
</div>
<div class="section" id="computing-frequencies">
<span id="bioinf-freqm"></span><h2>Computing Frequencies<a class="headerlink" href="#computing-frequencies" title="Permalink to this headline">¶</a></h2>
<p id="index-17">Your genetic code is essentially the same from you are born until you
die, and the same in your blood and your brain.  Which genes that are
turned on and off make the difference between the cells. This
regulation of genes is orchestrated by an immensely complex mechanism,
which we have only started to understand. A central part of this
mechanism consists of molecules called transcription factors that
float around in the cell and attach to DNA, and in doing so turn
nearby genes on or off. These molecules bind preferentially to
specific DNA sequences, and this binding preference pattern can be
represented by a table of frequencies of given symbols at each
position of the pattern.  More precisely, each row in the table
corresponds to the bases A, C, G, and T, while column j reflects how
many times the base appears in position j in the DNA sequence.</p>
<p>For example, if our set of DNA sequences are
TAG, GGT, and GGG, the table becomes</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">base</th>
<th class="head">0</th>
<th class="head">1</th>
<th class="head">2</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>A</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>C</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="row-even"><td>G</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr class="row-odd"><td>T</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>From this table we can read that base A appears once in index 1 in the
DNA strings, base C does not appear at all, base G appears twice in
all positions, and base T appears once in the beginning and end of the
strings.</p>
<p>In the following we shall present different data structures to
hold such a table and different ways of computing them.
The table is known as a <em>frequency matrix</em> in bioinformatics
and this is the term used here too.</p>
<div class="section" id="separate-frequency-lists">
<h3>Separate Frequency Lists<a class="headerlink" href="#separate-frequency-lists" title="Permalink to this headline">¶</a></h3>
<p>Since we know that there are only four rows in the frequency matrix,
an obvious data structure would be four lists, each holding
a row. A function computing these lists may look like</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">freq_lists</span><span class="p">(</span><span class="n">dna_list</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dna_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
    <span class="n">T</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
    <span class="n">G</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
    <span class="n">C</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
    <span class="k">for</span> <span class="n">dna</span> <span class="ow">in</span> <span class="n">dna_list</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dna</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">base</span> <span class="o">==</span> <span class="s">&#39;A&#39;</span><span class="p">:</span>
                <span class="n">A</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="s">&#39;C&#39;</span><span class="p">:</span>
                <span class="n">C</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="s">&#39;G&#39;</span><span class="p">:</span>
                <span class="n">G</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="s">&#39;T&#39;</span><span class="p">:</span>
                <span class="n">T</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">A</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">T</span>
</pre></div>
</div>
<p>We need to initialize the lists with the right length and a zero
for each element, since each list element is to be used as a counter.
Creating a list of length <tt class="docutils literal"><span class="pre">n</span></tt> with object <tt class="docutils literal"><span class="pre">x</span></tt> in all positions
is done by <tt class="docutils literal"><span class="pre">[x]*n</span></tt>. Finding the proper length is here carried out by
inspecting the length of the first element in <tt class="docutils literal"><span class="pre">dna_list</span></tt>, the list of
all DNA strings to be counted, assuming
that all elements in this list have the same length.</p>
<p id="index-18">In the <tt class="docutils literal"><span class="pre">for</span></tt> loop we apply the <tt class="docutils literal"><span class="pre">enumerate</span></tt> function, which is used
to extract both the element value <em>and</em> the element index when
iterating over a sequence. For example,</p>
<div class="highlight-text"><div class="highlight"><pre>&gt;&gt;&gt; for index, base in enumerate([&#39;t&#39;, &#39;e&#39;, &#39;s&#39;, &#39;t&#39;]):
...   print index, base
...
0 t
1 e
2 s
3 t
</pre></div>
</div>
<p>Here is a test,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dna_list</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;GGTAG&#39;</span><span class="p">,</span> <span class="s">&#39;GGTAC&#39;</span><span class="p">,</span> <span class="s">&#39;GGTGC&#39;</span><span class="p">]</span>
<span class="n">A</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">freq_lists</span><span class="p">(</span><span class="n">dna_list</span><span class="p">)</span>
<span class="k">print</span> <span class="n">A</span>
<span class="k">print</span> <span class="n">C</span>
<span class="k">print</span> <span class="n">G</span>
<span class="k">print</span> <span class="n">T</span>
</pre></div>
</div>
<p>with output</p>
<div class="highlight-text"><div class="highlight"><pre>[0, 0, 0, 2, 0]
[0, 0, 0, 0, 2]
[3, 3, 0, 1, 1]
[0, 0, 3, 0, 0]
</pre></div>
</div>
</div>
<div class="section" id="nested-list">
<h3>Nested List<a class="headerlink" href="#nested-list" title="Permalink to this headline">¶</a></h3>
<p>The frequency matrix can also be represented as a nested list <tt class="docutils literal"><span class="pre">M</span></tt>
such that <tt class="docutils literal"><span class="pre">M[i][j]</span></tt> is the frequency of base <tt class="docutils literal"><span class="pre">i</span></tt> in position <tt class="docutils literal"><span class="pre">j</span></tt>
in the set of DNA strings. Here <tt class="docutils literal"><span class="pre">i</span></tt> is an integer, where 0 corresponds to A,
1 to T, 2 to G, and 3 to C. The frequency is the number of times
base <tt class="docutils literal"><span class="pre">i</span></tt> appears in position <tt class="docutils literal"><span class="pre">j</span></tt> in a set of DNA strings.
Sometimes this number is divided by the number of DNA strings in
the set so that the frequency is between 0 and 1. Note that all
the DNA strings must have the same length.</p>
<p>The simplest way to make a nested list is to insert the
<tt class="docutils literal"><span class="pre">A</span></tt>, <tt class="docutils literal"><span class="pre">C</span></tt>, <tt class="docutils literal"><span class="pre">G</span></tt>, and <tt class="docutils literal"><span class="pre">T</span></tt> lists into another list:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">frequency_matrix</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">T</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frequency_matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>  <span class="c"># same element</span>
<span class="go">2</span>
</pre></div>
</div>
<p>Alternatively, we can illustrate how to compute this type of nested
list directly:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">freq_list_of_lists_v1</span><span class="p">(</span><span class="n">dna_list</span><span class="p">):</span>
    <span class="c"># Create empty frequency_matrix[i][j] = 0</span>
    <span class="c"># i=0,1,2,3 corresponds to A,T,G,C</span>
    <span class="c"># j=0,...,length of dna_list[0]</span>
    <span class="n">frequency_matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dna_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="s">&#39;ACGT&#39;</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">dna</span> <span class="ow">in</span> <span class="n">dna_list</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dna</span><span class="p">):</span>
          <span class="k">if</span> <span class="n">base</span> <span class="o">==</span> <span class="s">&#39;A&#39;</span><span class="p">:</span>
              <span class="n">frequency_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span><span class="mi">1</span>
          <span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="s">&#39;C&#39;</span><span class="p">:</span>
              <span class="n">frequency_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span><span class="mi">1</span>
          <span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="s">&#39;G&#39;</span><span class="p">:</span>
              <span class="n">frequency_matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span><span class="mi">1</span>
          <span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="s">&#39;T&#39;</span><span class="p">:</span>
              <span class="n">frequency_matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span><span class="mi">1</span>

    <span class="k">return</span> <span class="n">frequency_matrix</span>
</pre></div>
</div>
<p>As in the case with individual lists we need to initialize all elements
in the nested list to zero.</p>
<p>A call and printout,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dna_list</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;GGTAG&#39;</span><span class="p">,</span> <span class="s">&#39;GGTAC&#39;</span><span class="p">,</span> <span class="s">&#39;GGTGC&#39;</span><span class="p">]</span>
<span class="n">frequency_matrix</span> <span class="o">=</span> <span class="n">freq_list_of_lists_v1</span><span class="p">(</span><span class="n">dna_list</span><span class="p">)</span>
<span class="k">print</span> <span class="n">frequency_matrix</span>
</pre></div>
</div>
<p>results in</p>
<div class="highlight-text"><div class="highlight"><pre>[[0, 0, 0, 2, 0], [0, 0, 0, 0, 2], [3, 3, 0, 1, 1], [0, 0, 3, 0, 0]]
</pre></div>
</div>
</div>
<div class="section" id="dictionary-for-more-convenient-indexing">
<h3>Dictionary for More Convenient Indexing<a class="headerlink" href="#dictionary-for-more-convenient-indexing" title="Permalink to this headline">¶</a></h3>
<p id="index-19">The series of <tt class="docutils literal"><span class="pre">if</span></tt> tests in the Python function <tt class="docutils literal"><span class="pre">freq_list_of_lists_v1</span></tt>
are somewhat cumbersome,
especially if we want to extend the code to other bioinformatics problems
where the alphabet is larger. What we want is a mapping from <tt class="docutils literal"><span class="pre">base</span></tt>,
which is a character, to the corresponding index 0, 1, 2, or 3.
A Python dictionary may represent such mappings:</p>
<div class="highlight-text"><div class="highlight"><pre>&gt;&gt;&gt; base2index = {&#39;A&#39;: 0, &#39;C&#39;: 1, &#39;G&#39;: 2, &#39;T&#39;: 3}
&gt;&gt;&gt; base2index[&#39;G&#39;]
2
</pre></div>
</div>
<p>With the <tt class="docutils literal"><span class="pre">base2index</span></tt> dictionary we do not need the series of
<tt class="docutils literal"><span class="pre">if</span></tt> tests and the alphabet <tt class="docutils literal"><span class="pre">'ATGC'</span></tt> could be much larger
without affecting the length of the code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">freq_list_of_lists_v2</span><span class="p">(</span><span class="n">dna_list</span><span class="p">):</span>
    <span class="n">frequency_matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dna_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="s">&#39;ACGT&#39;</span><span class="p">]</span>
    <span class="n">base2index</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;G&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;T&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">dna</span> <span class="ow">in</span> <span class="n">dna_list</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dna</span><span class="p">):</span>
            <span class="n">frequency_matrix</span><span class="p">[</span><span class="n">base2index</span><span class="p">[</span><span class="n">base</span><span class="p">]][</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">frequency_matrix</span>
</pre></div>
</div>
</div>
<div class="section" id="numerical-python-array">
<h3>Numerical Python Array<a class="headerlink" href="#numerical-python-array" title="Permalink to this headline">¶</a></h3>
<p>As long as each sublist in a list of lists has the same length, a
list of lists can be replaced by a Numerical Python (<tt class="docutils literal"><span class="pre">numpy</span></tt>) array.
Processing of such arrays is often much more efficient than
processing of the nested list data structure.
To initialize a two-dimensional <tt class="docutils literal"><span class="pre">numpy</span></tt> array we need to know its
size, here 4 times <tt class="docutils literal"><span class="pre">len(dna_list[0])</span></tt>. Only the first line in the function
<tt class="docutils literal"><span class="pre">freq_list_of_lists_v2</span></tt> needs to be changed in order to utilize
a <tt class="docutils literal"><span class="pre">numpy</span></tt> array:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">freq_numpy</span><span class="p">(</span><span class="n">dna_list</span><span class="p">):</span>
    <span class="n">frequency_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dna_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
    <span class="n">base2index</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;G&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;T&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">dna</span> <span class="ow">in</span> <span class="n">dna_list</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dna</span><span class="p">):</span>
            <span class="n">frequency_matrix</span><span class="p">[</span><span class="n">base2index</span><span class="p">[</span><span class="n">base</span><span class="p">]][</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">frequency_matrix</span>
</pre></div>
</div>
<p>The resulting <tt class="docutils literal"><span class="pre">frequency_matrix</span></tt> object can be indexed as
<tt class="docutils literal"><span class="pre">[b][i]</span></tt> or <tt class="docutils literal"><span class="pre">[b,i]</span></tt>, with integers <tt class="docutils literal"><span class="pre">b</span></tt> and <tt class="docutils literal"><span class="pre">i</span></tt>. Typically, <tt class="docutils literal"><span class="pre">b</span></tt> will
be something line <tt class="docutils literal"><span class="pre">base2index['C']</span></tt>.</p>
</div>
<div class="section" id="dictionary-of-lists">
<h3>Dictionary of Lists<a class="headerlink" href="#dictionary-of-lists" title="Permalink to this headline">¶</a></h3>
<p>Instead of going from a character to an integer index via
<tt class="docutils literal"><span class="pre">base2index</span></tt>, we may prefer to index <tt class="docutils literal"><span class="pre">frequency_matrix</span></tt> by the base name
and the position index directly, like in <tt class="docutils literal"><span class="pre">['C'][14]</span></tt>.
This is the most natural syntax for a user of the
frequency matrix.  The relevant Python data structure is then a
dictionary of lists. That is, <tt class="docutils literal"><span class="pre">frequency_matrix</span></tt> is a dictionary with
keys <tt class="docutils literal"><span class="pre">'A'</span></tt>, <tt class="docutils literal"><span class="pre">'C'</span></tt>, <tt class="docutils literal"><span class="pre">'G'</span></tt>, and <tt class="docutils literal"><span class="pre">'T'</span></tt>. The value for each key is a
list. Let us now also extend the flexibility such that <tt class="docutils literal"><span class="pre">dna_list</span></tt> can
have DNA strings of different lengths. The lists in <tt class="docutils literal"><span class="pre">frequency_list</span></tt>
will have lengths equal to the longest DNA string.  A relevant
function is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">freq_dict_of_lists_v1</span><span class="p">(</span><span class="n">dna_list</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">dna</span><span class="p">)</span> <span class="k">for</span> <span class="n">dna</span> <span class="ow">in</span> <span class="n">dna_list</span><span class="p">])</span>
    <span class="n">frequency_matrix</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">,</span>
        <span class="s">&#39;C&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">,</span>
        <span class="s">&#39;G&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">,</span>
        <span class="s">&#39;T&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="k">for</span> <span class="n">dna</span> <span class="ow">in</span> <span class="n">dna_list</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dna</span><span class="p">):</span>
            <span class="n">frequency_matrix</span><span class="p">[</span><span class="n">base</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">frequency_matrix</span>
</pre></div>
</div>
<p>Running the test code</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">frequency_matrix</span> <span class="o">=</span> <span class="n">freq_dict_of_lists_v1</span><span class="p">(</span><span class="n">dna_list</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">pprint</span>   <span class="c"># for nice printout of nested data structures</span>
<span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">frequency_matrix</span><span class="p">)</span>
</pre></div>
</div>
<p>results in the output</p>
<div class="highlight-text"><div class="highlight"><pre>{&#39;A&#39;: [0, 0, 0, 2, 0],
 &#39;C&#39;: [0, 0, 0, 0, 2],
 &#39;G&#39;: [3, 3, 0, 1, 1],
 &#39;T&#39;: [0, 0, 3, 0, 0]}
</pre></div>
</div>
<p>The initialization of <tt class="docutils literal"><span class="pre">frequency_matrix</span></tt> in the above code can
be made more compact by using a dictionary comprehension:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">value</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">some_sequence</span><span class="p">}</span>
</pre></div>
</div>
<p>In our example we set</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">frequency_matrix</span> <span class="o">=</span> <span class="p">{</span><span class="n">base</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span> <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="s">&#39;ACGT&#39;</span><span class="p">}</span>
</pre></div>
</div>
<p>Adopting this construction in the <tt class="docutils literal"><span class="pre">freq_dict_of_lists_v1</span></tt> function
leads to a slightly more compact version:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">freq_dict_of_lists_v2</span><span class="p">(</span><span class="n">dna_list</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">dna</span><span class="p">)</span> <span class="k">for</span> <span class="n">dna</span> <span class="ow">in</span> <span class="n">dna_list</span><span class="p">])</span>
    <span class="n">frequency_matrix</span> <span class="o">=</span> <span class="p">{</span><span class="n">base</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span> <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="s">&#39;ACGT&#39;</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">dna</span> <span class="ow">in</span> <span class="n">dna_list</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dna</span><span class="p">):</span>
            <span class="n">frequency_matrix</span><span class="p">[</span><span class="n">base</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">frequency_matrix</span>
</pre></div>
</div>
<p id="index-20">As an additional comment on computing the maximum length of the DNA
strings can be made as there are several alternative ways of doing
this.  The classical use of <tt class="docutils literal"><span class="pre">max</span></tt> is to apply it to a list as done
above:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">n</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">dna</span><span class="p">)</span> <span class="k">for</span> <span class="n">dna</span> <span class="ow">in</span> <span class="n">dna_list</span><span class="p">])</span>
</pre></div>
</div>
<p>However, for very long lists it is possible to avoid the memory demands
of storing the result of the list comprehension, i.e., the list of
lengths. Instead <tt class="docutils literal"><span class="pre">max</span></tt> can work with the lengths as they are computed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">n</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dna</span><span class="p">)</span> <span class="k">for</span> <span class="n">dna</span> <span class="ow">in</span> <span class="n">dna_list</span><span class="p">)</span>
</pre></div>
</div>
<p>It is also possible to write</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">n</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dna_list</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, <tt class="docutils literal"><span class="pre">len</span></tt> is applied to each element in <tt class="docutils literal"><span class="pre">dna_list</span></tt>, and the
maximum of the resulting values is returned.</p>
</div>
<div class="section" id="dictionary-of-dictionaries">
<h3>Dictionary of Dictionaries<a class="headerlink" href="#dictionary-of-dictionaries" title="Permalink to this headline">¶</a></h3>
<p>The dictionary of lists data structure can alternatively be replaced
by a dictionary of dictionaries object, often just called a dict of
dicts object. That is, <tt class="docutils literal"><span class="pre">frequency_matrix[base]</span></tt> is a dictionary with
key <tt class="docutils literal"><span class="pre">i</span></tt> and value equal to the added number of occurrences of <tt class="docutils literal"><span class="pre">base</span></tt> in
<tt class="docutils literal"><span class="pre">dna[i]</span></tt> for all <tt class="docutils literal"><span class="pre">dna</span></tt> strings in the list <tt class="docutils literal"><span class="pre">dna_list</span></tt>.  The indexing
<tt class="docutils literal"><span class="pre">frequency_matrix['C'][i]</span></tt> and the values are exactly as in the last
example; the only difference is whether <tt class="docutils literal"><span class="pre">frequency_matrix['C']</span></tt> is a
list or dictionary.</p>
<p>Our function working with <tt class="docutils literal"><span class="pre">frequency_matrix</span></tt> as a dict of dicts
is written as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">freq_dict_of_dicts_v1</span><span class="p">(</span><span class="n">dna_list</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">dna</span><span class="p">)</span> <span class="k">for</span> <span class="n">dna</span> <span class="ow">in</span> <span class="n">dna_list</span><span class="p">])</span>
    <span class="n">frequency_matrix</span> <span class="o">=</span> <span class="p">{</span><span class="n">base</span><span class="p">:</span> <span class="p">{</span><span class="n">index</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)}</span>
                        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="s">&#39;ACGT&#39;</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">dna</span> <span class="ow">in</span> <span class="n">dna_list</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dna</span><span class="p">):</span>
            <span class="n">frequency_matrix</span><span class="p">[</span><span class="n">base</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">frequency_matrix</span>
</pre></div>
</div>
</div>
<div class="section" id="using-dictionaries-with-default-values">
<h3>Using Dictionaries with Default Values<a class="headerlink" href="#using-dictionaries-with-default-values" title="Permalink to this headline">¶</a></h3>
<p>The manual initialization of each subdictionary to zero,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">frequency_matrix</span> <span class="o">=</span> <span class="p">{</span><span class="n">base</span><span class="p">:</span> <span class="p">{</span><span class="n">index</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)}</span>
                    <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="s">&#39;ACGT&#39;</span><span class="p">}</span>
</pre></div>
</div>
<p>can be simplified by using a dictionary with default values for any
key. The construction <tt class="docutils literal"><span class="pre">defaultdict(lambda:</span> <span class="pre">obj)</span></tt>
makes a dictionary with <tt class="docutils literal"><span class="pre">obj</span></tt> as default value.
This construction simplifies the previous function a bit:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="k">def</span> <span class="nf">freq_dict_of_dicts_v2</span><span class="p">(</span><span class="n">dna_list</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">dna</span><span class="p">)</span> <span class="k">for</span> <span class="n">dna</span> <span class="ow">in</span> <span class="n">dna_list</span><span class="p">])</span>
    <span class="n">frequency_matrix</span> <span class="o">=</span> <span class="p">{</span><span class="n">base</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="s">&#39;ACGT&#39;</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">dna</span> <span class="ow">in</span> <span class="n">dna_list</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dna</span><span class="p">):</span>
            <span class="n">frequency_matrix</span><span class="p">[</span><span class="n">base</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">frequency_matrix</span>
</pre></div>
</div>
<p><strong>Remark.</strong>
Dictionary comprehensions were new in Python 2.7 and 3.1, but can be
simulated in earlier versions by making (key, value) tuples via
list comprehensions. A dictionary comprehension</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">value</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">}</span>
</pre></div>
</div>
<p>is then constructed as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="using-arrays-and-vectorization">
<h3>Using Arrays and Vectorization<a class="headerlink" href="#using-arrays-and-vectorization" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">frequency_matrix</span></tt> dict of lists for can easily be
changed to a dict of <tt class="docutils literal"><span class="pre">numpy</span></tt> arrays: just replace the initialization
<tt class="docutils literal"><span class="pre">[0]*n</span></tt> by <tt class="docutils literal"><span class="pre">np.zeros(n,</span> <span class="pre">dtype=np.int)</span></tt>. The indexing remains the same:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">freq_dict_of_arrays_v1</span><span class="p">(</span><span class="n">dna_list</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">dna</span><span class="p">)</span> <span class="k">for</span> <span class="n">dna</span> <span class="ow">in</span> <span class="n">dna_list</span><span class="p">])</span>
    <span class="n">frequency_matrix</span> <span class="o">=</span> <span class="p">{</span><span class="n">base</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="s">&#39;ACGT&#39;</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">dna</span> <span class="ow">in</span> <span class="n">dna_list</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dna</span><span class="p">):</span>
            <span class="n">frequency_matrix</span><span class="p">[</span><span class="n">base</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">frequency_matrix</span>
</pre></div>
</div>
<p>Having <tt class="docutils literal"><span class="pre">frequency_matrix[base]</span></tt> as a <tt class="docutils literal"><span class="pre">numpy</span></tt> array instead of a list
does not give any immediate advantage, as the storage and CPU time is
about the same. The loop over the <tt class="docutils literal"><span class="pre">dna</span></tt> string and the associated
indexing is what consumes all the CPU time.  However, the <tt class="docutils literal"><span class="pre">numpy</span></tt>
arrays provide a potential for increasing efficiency through
vectorization, i.e., replacing the element-wise operations on <tt class="docutils literal"><span class="pre">dna</span></tt>
and <tt class="docutils literal"><span class="pre">frequency_matrix[base]</span></tt> by operations on the entire arrays at
once.</p>
<p>Let us use the interactive Python shell to
explore the possibilities of vectorization.
We first convert the string to a <tt class="docutils literal"><span class="pre">numpy</span></tt> array of characters:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dna</span> <span class="o">=</span> <span class="s">&#39;ACAT&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dna</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dna</span>
<span class="go">array([&#39;A&#39;, &#39;C&#39;, &#39;A&#39;, &#39;T&#39;],</span>
<span class="go">      dtype=&#39;|S1&#39;)</span>
</pre></div>
</div>
<p>For a given base, say A, we can in one vectorized operation find
which locations in <tt class="docutils literal"><span class="pre">dna</span></tt> that contain <tt class="docutils literal"><span class="pre">A</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">dna</span> <span class="o">==</span> <span class="s">&#39;A&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([ True, False,  True, False], dtype=bool)</span>
</pre></div>
</div>
<p>By converting <tt class="docutils literal"><span class="pre">b</span></tt> to an integer array <tt class="docutils literal"><span class="pre">i</span></tt> we can
update the frequency counts
for all indices by adding <tt class="docutils literal"><span class="pre">i</span></tt> to <tt class="docutils literal"><span class="pre">frequency_matrix['A']</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span>
<span class="go">array([1, 0, 1, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frequency_matrix</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">frequency_matrix</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span>
</pre></div>
</div>
<p>This recipe can be repeated for all bases:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">dna</span> <span class="ow">in</span> <span class="n">dna_list</span><span class="p">:</span>
    <span class="n">dna</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="s">&#39;ACGT&#39;</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">dna</span> <span class="o">==</span> <span class="n">base</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="n">frequency_matrix</span><span class="p">[</span><span class="n">base</span><span class="p">]</span> <span class="o">=</span> <span class="n">frequency_matrix</span><span class="p">[</span><span class="n">base</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span>
</pre></div>
</div>
<p>It turns out that we do not need to convert the boolean array <tt class="docutils literal"><span class="pre">b</span></tt>
to an integer array <tt class="docutils literal"><span class="pre">i</span></tt>, because doing arithmetics with <tt class="docutils literal"><span class="pre">b</span></tt> directly
is possible: <tt class="docutils literal"><span class="pre">False</span></tt> is interpreted as 0 and <tt class="docutils literal"><span class="pre">True</span></tt> as 1 in arithmetic
operations.  We can also use
the <tt class="docutils literal"><span class="pre">+=</span></tt> operator to update all elements of <tt class="docutils literal"><span class="pre">frequency_matrix[base]</span></tt>
directly, without first computing the sum of two arrays
<tt class="docutils literal"><span class="pre">frequency_matrix[base]</span> <span class="pre">+</span> <span class="pre">i</span></tt> and then assigning this result to
<tt class="docutils literal"><span class="pre">frequency_matrix[base]</span></tt>.
Collecting all these ideas in one function yields the code</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">freq_dict_of_arrays_v2</span><span class="p">(</span><span class="n">dna_list</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">dna</span><span class="p">)</span> <span class="k">for</span> <span class="n">dna</span> <span class="ow">in</span> <span class="n">dna_list</span><span class="p">])</span>
    <span class="n">frequency_matrix</span> <span class="o">=</span> <span class="p">{</span><span class="n">base</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="s">&#39;ACGT&#39;</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">dna</span> <span class="ow">in</span> <span class="n">dna_list</span><span class="p">:</span>
        <span class="n">dna</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="s">&#39;ACCT&#39;</span><span class="p">:</span>
            <span class="n">frequency_matrix</span><span class="p">[</span><span class="n">base</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dna</span> <span class="o">==</span> <span class="n">base</span>

    <span class="k">return</span> <span class="n">frequency_matrix</span>
</pre></div>
</div>
<p>This vectorized function runs almost 10 times as fast as the
(scalar) counterpart <tt class="docutils literal"><span class="pre">freq_list_of_arrays_v1</span></tt>!</p>
</div>
</div>
<div class="section" id="analyzing-the-frequency-matrix">
<span id="bioinf-freq-analysis"></span><h2>Analyzing the Frequency Matrix<a class="headerlink" href="#analyzing-the-frequency-matrix" title="Permalink to this headline">¶</a></h2>
<p>Having built a frequency matrix out of a collection of DNA strings, it
is time to use it for analysis.
The short DNA strings that a frequency matrix is built out of, is
typically a set of substrings of a larger DNA sequence, which shares
some common purpose. An example of this is to have a set of substrings
that serves as a kind of anchors/magnets at which given molecules
attach to DNA and perform biological functions (like turning genes on
or off). With the frequency matrix constructed from a limited set of
known anchor locations (substrings), we can now scan for other similar
substrings that have the potential to perform the same function. The
simplest way to do this is to first determine the most typical
substring according to the frequency matrix, i.e., the substring having
the most frequent nucleotide at each position. This is referred to as
the consensus string of the frequency matrix. We can then look for
occurrences of the consensus substring in a larger DNA sequence, and
consider these occurrences as likely candidates for serving the same
function (e.g., as anchor locations for molecules).</p>
<p>For instance,
given three substrings ACT, CCA and AGA, the frequency matrix
would be (list of lists, with rows corresponding to A, C, G, and T):</p>
<div class="highlight-text"><div class="highlight"><pre>[[2, 0, 2]
 [1, 2, 0]
 [0, 1, 0]
 [0, 0, 1]]
</pre></div>
</div>
<p>We see that for position 0,
which corresponds to the left-most column in the table, the symbol A has the
highest frequency (2). The maximum frequencies for the other positions
are seen to be C for position 1, and A for position 2. The consensus
string is therefore ACA.  Note that the consensus string does not need to be
equal to any of the substrings that formed the basis of the frequency
matrix (this is indeed the case for the above example).</p>
<div class="section" id="list-of-lists-frequency-matrix">
<h3>List of Lists Frequency Matrix<a class="headerlink" href="#list-of-lists-frequency-matrix" title="Permalink to this headline">¶</a></h3>
<p>Let <tt class="docutils literal"><span class="pre">frequency_matrix</span></tt> be a list of lists. For each position <tt class="docutils literal"><span class="pre">i</span></tt> we
run through the rows in the frequency matrix and keep track of the
maximum frequency value and the corresponding letter. If two or
more letters have the same frequency value we use a dash to
indicate that this position in the consensus string is undetermined.</p>
<p>The following function computes the consensus string:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">find_consensus_v1</span><span class="p">(</span><span class="n">frequency_matrix</span><span class="p">):</span>
    <span class="n">base2index</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;G&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;T&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
    <span class="n">consensus</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
    <span class="n">dna_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frequency_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dna_length</span><span class="p">):</span>  <span class="c"># loop over positions in string</span>
        <span class="n">max_freq</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>            <span class="c"># holds the max freq. for this i</span>
        <span class="n">max_freq_base</span> <span class="o">=</span> <span class="bp">None</span>     <span class="c"># holds the corresponding base</span>

        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="s">&#39;ATGC&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">frequency_matrix</span><span class="p">[</span><span class="n">base2index</span><span class="p">[</span><span class="n">base</span><span class="p">]][</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_freq</span><span class="p">:</span>
                <span class="n">max_freq</span> <span class="o">=</span> <span class="n">frequency_matrix</span><span class="p">[</span><span class="n">base2index</span><span class="p">[</span><span class="n">base</span><span class="p">]][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">max_freq_base</span> <span class="o">=</span> <span class="n">base</span>
            <span class="k">elif</span> <span class="n">frequency_matrix</span><span class="p">[</span><span class="n">base2index</span><span class="p">[</span><span class="n">base</span><span class="p">]][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">max_freq</span><span class="p">:</span>
                <span class="n">max_freq_base</span> <span class="o">=</span> <span class="s">&#39;-&#39;</span> <span class="c"># more than one base as max</span>

        <span class="n">consensus</span> <span class="o">+=</span> <span class="n">max_freq_base</span>  <span class="c"># add new base with max freq</span>
    <span class="k">return</span> <span class="n">consensus</span>
</pre></div>
</div>
<p>Since this code requires <tt class="docutils literal"><span class="pre">frequency_matrix</span></tt> to be a list of lists
we should insert a test and raise an exception if the
type is wrong:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">find_consensus_v1</span><span class="p">(</span><span class="n">frequency_matrix</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">frequency_matrix</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> \
       <span class="nb">isinstance</span><span class="p">(</span><span class="n">frequency_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">pass</span> <span class="c"># right type</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;frequency_matrix must be list of lists&#39;</span><span class="p">)</span>
    <span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="dict-of-dicts-frequency-matrix">
<h3>Dict of Dicts Frequency Matrix<a class="headerlink" href="#dict-of-dicts-frequency-matrix" title="Permalink to this headline">¶</a></h3>
<p>How must the <tt class="docutils literal"><span class="pre">find_consensus_v1</span></tt> function be altered if <tt class="docutils literal"><span class="pre">frequency_matrix</span></tt>
is a dict of dicts?</p>
<blockquote>
<div><ol class="arabic simple">
<li>The <tt class="docutils literal"><span class="pre">base2index</span></tt> dict is no longer needed.</li>
<li>Access of sublist, <tt class="docutils literal"><span class="pre">frequency_matrix[0]</span></tt>, to test for type and
length of the strings, must be replaced
by <tt class="docutils literal"><span class="pre">frequency_matrix['A']</span></tt>.</li>
</ol>
</div></blockquote>
<p>The updated function becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">find_consensus_v3</span><span class="p">(</span><span class="n">frequency_matrix</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">frequency_matrix</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> \
       <span class="nb">isinstance</span><span class="p">(</span><span class="n">frequency_matrix</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">pass</span> <span class="c"># right type</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;frequency_matrix must be dict of dicts&#39;</span><span class="p">)</span>

    <span class="n">consensus</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
    <span class="n">dna_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frequency_matrix</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dna_length</span><span class="p">):</span>  <span class="c"># loop over positions in string</span>
        <span class="n">max_freq</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>            <span class="c"># holds the max freq. for this i</span>
        <span class="n">max_freq_base</span> <span class="o">=</span> <span class="bp">None</span>     <span class="c"># holds the corresponding base</span>

        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="s">&#39;ACGT&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">frequency_matrix</span><span class="p">[</span><span class="n">base</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_freq</span><span class="p">:</span>
                <span class="n">max_freq</span> <span class="o">=</span> <span class="n">frequency_matrix</span><span class="p">[</span><span class="n">base</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">max_freq_base</span> <span class="o">=</span> <span class="n">base</span>
            <span class="k">elif</span> <span class="n">frequency_matrix</span><span class="p">[</span><span class="n">base</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">max_freq</span><span class="p">:</span>
                <span class="n">max_freq_base</span> <span class="o">=</span> <span class="s">&#39;-&#39;</span> <span class="c"># more than one base as max</span>

        <span class="n">consensus</span> <span class="o">+=</span> <span class="n">max_freq_base</span>  <span class="c"># add new base with max freq</span>
    <span class="k">return</span> <span class="n">consensus</span>
</pre></div>
</div>
<p>Here is a test:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">frequency_matrix</span> <span class="o">=</span> <span class="n">freq_dict_of_dicts_v1</span><span class="p">(</span><span class="n">dna_list</span><span class="p">)</span>
<span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">frequency_matrix</span><span class="p">)</span>
<span class="k">print</span> <span class="n">find_consensus_v3</span><span class="p">(</span><span class="n">frequency_matrix</span><span class="p">)</span>
</pre></div>
</div>
<p>with output</p>
<div class="highlight-text"><div class="highlight"><pre>{&#39;A&#39;: {0: 0, 1: 0, 2: 0, 3: 2, 4: 0},
 &#39;C&#39;: {0: 0, 1: 0, 2: 0, 3: 0, 4: 2},
 &#39;G&#39;: {0: 3, 1: 3, 2: 0, 3: 1, 4: 1},
 &#39;T&#39;: {0: 0, 1: 0, 2: 3, 3: 0, 4: 0}}
Consensus string: GGTAC
</pre></div>
</div>
<p>Let us try <tt class="docutils literal"><span class="pre">find_consensus_v3</span></tt> with the dict of defaultdicts
as input (<tt class="docutils literal"><span class="pre">freq_dicts_of_dicts_v2</span></tt>). The code runs fine, but
the output string is just <tt class="docutils literal"><span class="pre">G</span></tt>!
The reason is that <tt class="docutils literal"><span class="pre">dna_length</span></tt> is 1, and therefore that the length of
the <tt class="docutils literal"><span class="pre">A</span></tt> dict in <tt class="docutils literal"><span class="pre">frequency_matrix</span></tt> is 1.
Printing out <tt class="docutils literal"><span class="pre">frequency_matrix</span></tt> yields</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">{</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="p">{</span><span class="mi">3</span><span class="p">:</span> <span class="mi">2</span><span class="p">}),</span>
 <span class="s">&#39;C&#39;</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="p">{</span><span class="mi">4</span><span class="p">:</span> <span class="mi">2</span><span class="p">}),</span>
 <span class="s">&#39;G&#39;</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="mi">1</span><span class="p">}),</span>
 <span class="s">&#39;T&#39;</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="mi">3</span><span class="p">})}</span>
</pre></div>
</div>
<p>where our <tt class="docutils literal"><span class="pre">X</span></tt> is a short form for text like</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sb">`&lt;function &lt;lambda&gt; at 0xfaede8&gt;`</span>
</pre></div>
</div>
<p>We see that the length of a defaultdict will only count the nonzero
entries. Hence, to use a defaultdict our function must get the length of the DNA string to
build as an extra argument:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">find_consensus_v4</span><span class="p">(</span><span class="n">frequency_matrix</span><span class="p">,</span> <span class="n">dna_length</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="#bioinf-exer-freq-fargs"><em>Exercise 3: Allow different types for a function argument</em></a> suggests to make a unified
<tt class="docutils literal"><span class="pre">find_consensus</span></tt> function which works with all of the different
representations of <tt class="docutils literal"><span class="pre">frequency_matrix</span></tt> that we have used.</p>
<p>The functions making and using the frequency matrix are found
in the file <a class="reference external" href="http://tinyurl.com/q4qpjbt/freq.py">freq.py</a>.</p>
</div>
</div>
<div class="section" id="dot-plots-from-pair-of-dna-sequences">
<span id="bioinf-dotplot"></span><h2>Dot Plots from Pair of DNA Sequences<a class="headerlink" href="#dot-plots-from-pair-of-dna-sequences" title="Permalink to this headline">¶</a></h2>
<p>Dot plots are commonly used to visualize the similarity between two protein or
nucleic acid sequences. They compare two sequences, say <tt class="docutils literal"><span class="pre">d1</span></tt> and <tt class="docutils literal"><span class="pre">d2</span></tt>,
by organizing <tt class="docutils literal"><span class="pre">d1</span></tt>
along the x-axis and <tt class="docutils literal"><span class="pre">d2</span></tt> along the y-axis of a plot.
When <tt class="docutils literal"><span class="pre">d1[i]</span> <span class="pre">==</span> <span class="pre">d2[j]</span></tt> we mark this by drawing a dot at location
<tt class="docutils literal"><span class="pre">i,j</span></tt> in the plot. An example is</p>
<div class="highlight-text"><div class="highlight"><pre>1 0 0 1 0 0 0 1 0 0 0 1
0 1 1 0 0 0 0 0 0 1 1 0
0 1 1 0 0 0 0 0 0 1 1 0
1 0 0 1 0 0 0 1 0 0 0 1
0 0 0 0 1 0 0 0 1 0 0 0
0 0 0 0 0 1 1 0 0 0 0 0
0 0 0 0 0 1 1 0 0 0 0 0
1 0 0 1 0 0 0 1 0 0 0 1
0 0 0 0 1 0 0 0 1 0 0 0
0 1 1 0 0 0 0 0 0 1 1 0
0 1 1 0 0 0 0 0 0 1 1 0
1 0 0 1 0 0 0 1 0 0 0 1
</pre></div>
</div>
<p>The origin is in the upper left corner, which means that the
first string has its indices running to the right 0, 1, 2, and so forth,
while the second string has its indices running down, row by row.</p>
<p>In the forthcoming examples, a dot is represented by 1. No presence at
a given location is represented by 0. A dot plot can be manually read
to find common patterns between two sequences that has undergone
several insertions and deletions, and it serves as a conceptual basis
for algorithms that align two sequences in order to find evolutionary
origin or shared functional parts. Such alignment of biological
sequences is a particular variant of finding the edit distance between
strings, which is a general technique, also used for, e.g., spell
correction in search engines.</p>
<p>The dot plot data structure must mimic a table.  The &#8220;x&#8221; direction is
along rows, while the &#8220;y&#8221; direction is along columns. First we need to
initialize the whole data structure with zeros. Then, for each for
each position in the &#8220;x string&#8221; we run through all positions in the &#8220;y
string&#8221; and mark those where the characters match with 1.
The algorithm will be clear when presented with specific Python code.</p>
<div class="section" id="using-lists-of-lists">
<h3>Using Lists of Lists<a class="headerlink" href="#using-lists-of-lists" title="Permalink to this headline">¶</a></h3>
<p>Since the plot is essentially a table, a list of lists is therefore
a natural data structure. The following function creates the
list of lists:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">dotplot_list_of_lists</span><span class="p">(</span><span class="n">dna_x</span><span class="p">,</span> <span class="n">dna_y</span><span class="p">):</span>
    <span class="n">dotplot_matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="s">&#39;0&#39;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dna_x</span><span class="p">]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">dna_y</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">x_index</span><span class="p">,</span> <span class="n">x_value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dna_x</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">y_index</span><span class="p">,</span> <span class="n">y_value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dna_y</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x_value</span> <span class="o">==</span> <span class="n">y_value</span><span class="p">:</span>
                <span class="n">dotplot_matrix</span><span class="p">[</span><span class="n">y_index</span><span class="p">][</span><span class="n">x_index</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;1&#39;</span>
    <span class="k">return</span> <span class="n">dotplot_matrix</span>
</pre></div>
</div>
<p>To view the dot plot we need to print out the list of lists. Here
is a possible way:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dna_x</span> <span class="o">=</span> <span class="s">&#39;TAATGCCTGAAT&#39;</span>
<span class="n">dna_y</span> <span class="o">=</span> <span class="s">&#39;CTCTATGCC&#39;</span>

<span class="n">M</span> <span class="o">=</span> <span class="n">dotplot_list_of_lists</span><span class="p">(</span><span class="n">dna_x</span><span class="p">,</span> <span class="n">dna_x</span><span class="p">)</span>
<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">M</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">row</span><span class="p">:</span>
        <span class="k">print</span> <span class="n">column</span><span class="p">,</span>
    <span class="k">print</span>
</pre></div>
</div>
<p>The output becomes</p>
<div class="highlight-text"><div class="highlight"><pre>1 0 0 1 0 0 0 1 0 0 0 1
0 1 1 0 0 0 0 0 0 1 1 0
0 1 1 0 0 0 0 0 0 1 1 0
1 0 0 1 0 0 0 1 0 0 0 1
0 0 0 0 1 0 0 0 1 0 0 0
0 0 0 0 0 1 1 0 0 0 0 0
0 0 0 0 0 1 1 0 0 0 0 0
1 0 0 1 0 0 0 1 0 0 0 1
0 0 0 0 1 0 0 0 1 0 0 0
0 1 1 0 0 0 0 0 0 1 1 0
0 1 1 0 0 0 0 0 0 1 1 0
1 0 0 1 0 0 0 1 0 0 0 1
</pre></div>
</div>
<p>One can, alternatively, translate the list of lists to a multi-line string
containing the whole plot as a string object.
This implies joining all the characters in each row and then joining
all the rows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">rows</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dotplot_matrix</span><span class="p">]</span>
<span class="n">plot</span> <span class="o">=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
<span class="c"># or combined</span>
<span class="n">plot</span> <span class="o">=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dotplot_matrix</span><span class="p">])</span>
</pre></div>
</div>
<p>The construction <tt class="docutils literal"><span class="pre">'d'.join(l)</span></tt> joints
all the string elements of the
list <tt class="docutils literal"><span class="pre">l</span></tt> and inserts <tt class="docutils literal"><span class="pre">d</span></tt> as delimiter: <tt class="docutils literal"><span class="pre">'x'.join(['A','B','C'])</span></tt>
becomes <tt class="docutils literal"><span class="pre">'AxBxC'</span></tt>.
We use a space as delimiter among the characters in a row since this
gives a nice layout when printing the string. All rows are joined with
newline as delimiter such that the rows appear on separate lines when
printing the string.  To really understand what is going on, a more
comprehensive code could be made so that each step can be examined:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">make_string_expanded</span><span class="p">(</span><span class="n">dotplot_matrix</span><span class="p">):</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dotplot_matrix</span><span class="p">:</span>
        <span class="n">row_string</span> <span class="o">=</span> <span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row_string</span><span class="p">)</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">plot</span>

<span class="n">M2</span> <span class="o">=</span> <span class="p">[[</span><span class="s">&#39;1&#39;</span><span class="p">,</span> <span class="s">&#39;1&#39;</span><span class="p">,</span> <span class="s">&#39;0&#39;</span><span class="p">,</span> <span class="s">&#39;1&#39;</span><span class="p">],</span>
     <span class="p">[</span><span class="s">&#39;1&#39;</span><span class="p">,</span> <span class="s">&#39;1&#39;</span><span class="p">,</span> <span class="s">&#39;1&#39;</span><span class="p">,</span> <span class="s">&#39;1&#39;</span><span class="p">],</span>
     <span class="p">[</span><span class="s">&#39;0&#39;</span><span class="p">,</span> <span class="s">&#39;0&#39;</span><span class="p">,</span> <span class="s">&#39;1&#39;</span><span class="p">,</span> <span class="s">&#39;0&#39;</span><span class="p">],</span>
     <span class="p">[</span><span class="s">&#39;0&#39;</span><span class="p">,</span> <span class="s">&#39;0&#39;</span><span class="p">,</span> <span class="s">&#39;0&#39;</span><span class="p">,</span> <span class="s">&#39;1&#39;</span><span class="p">]]</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">make_string_expanded</span><span class="p">(</span><span class="n">M2</span><span class="p">)</span>
</pre></div>
</div>
<p>Unless the join operation as used here is well understood, it is highly
recommended to paste the above code into the
<a class="reference external" href="http://www.pythontutor.com/">Online Python Tutor</a>,
step through the code, and watch how variables change their content.
Figure <a class="reference internal" href="#bioinf-fig-pot2"><em>Illustration of how join operations work (using the Online Python Tutor)</em></a> shows a snapshot of this type of code investigation.</p>
<div class="figure" id="bioinf-fig-pot2">
<img alt="_images/pot_join.jpg" src="_images/pot_join.jpg" style="width: 850px;" />
<p class="caption"><em>Illustration of how join operations work (using the Online Python Tutor)</em></p>
</div>
</div>
<div class="section" id="using-numerical-python-arrays">
<h3>Using Numerical Python Arrays<a class="headerlink" href="#using-numerical-python-arrays" title="Permalink to this headline">¶</a></h3>
<p>A Numerical Python array, with integer elements that equal 0 or 1,
is well suited as data structure to hold a dot plot.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">dotplot_numpy</span><span class="p">(</span><span class="n">dna_x</span><span class="p">,</span> <span class="n">dna_y</span><span class="p">):</span>
    <span class="n">dotplot_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">dna_y</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">dna_x</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">x_index</span><span class="p">,</span> <span class="n">x_value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dna_x</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">y_index</span><span class="p">,</span> <span class="n">y_value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dna_y</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x_value</span> <span class="o">==</span> <span class="n">y_value</span><span class="p">:</span>
                <span class="n">dotplot_matrix</span><span class="p">[</span><span class="n">y_index</span><span class="p">,</span><span class="n">x_index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">dotplot_matrix</span>

<span class="k">print</span> <span class="n">dotplot_numpy</span><span class="p">(</span><span class="n">dna_x</span><span class="p">,</span> <span class="n">dna_y</span><span class="p">)</span>
</pre></div>
</div>
<p>The two dot plot functions are available
in the file <a class="reference external" href="http://tinyurl.com/q4qpjbt/dotplot.py">dotplot.py</a>.</p>
</div>
</div>
<div class="section" id="finding-base-frequencies">
<span id="bioinf-basefreq"></span><h2>Finding Base Frequencies<a class="headerlink" href="#finding-base-frequencies" title="Permalink to this headline">¶</a></h2>
<p>DNA consists of four molecules called nucleotides, or bases, and can
be represented as a string of the letters A, C, G, and T. But this
does not mean that all four nucleotides need to be similarly
frequent. Are some nucleotides more frequent than others, say in
yeast, as represented by the first chromosome of yeast? Also, DNA is
really not a single thread, but two threads wound together.  This
wounding is based on an A from one thread binding to a T of the other
thread, and C binding to G (that is, A will only bind with T, not with
C or G).  Could this fact force groups of the four symbol frequencies
to be equal?  The answer is that the A-T and G-C binding does not in principle
force certain frequencies to be equal, but in practice they usually
become so because of evolutionary factors related to this pairing.</p>
<p>Our first programming task now is to compute the frequencies of the
bases A, C, G, and T. That is, the number of times each base occurs in
the DNA string, divided by the length of the string.  For example, if
the DNA string is ACGGAAA, the length is 7, A appears 4 times with
frequency 4/7, C appears once with frequency 1/7, G appears twice with
frequency 2/7, and T does not appear so the frequency is 0.</p>
<p>From a coding perspective we may create a function for counting how
many times A, C, G, and T appears in the string and then another
function for computing the frequencies. In both cases we want
dictionaries such that we can index with the character and get the
count or the frequency out.
Counting is done by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">get_base_counts</span><span class="p">(</span><span class="n">dna</span><span class="p">):</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;T&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;G&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">dna</span><span class="p">:</span>
        <span class="n">counts</span><span class="p">[</span><span class="n">base</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">counts</span>
</pre></div>
</div>
<p>This function can then be used to compute the base frequencies:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">get_base_frequencies_v1</span><span class="p">(</span><span class="n">dna</span><span class="p">):</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">get_base_counts</span><span class="p">(</span><span class="n">dna</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">base</span><span class="p">:</span> <span class="n">count</span><span class="o">*</span><span class="mf">1.0</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">dna</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">base</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">counts</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
</pre></div>
</div>
<p>Since we learned at the end of the section <a class="reference internal" href="#bioinf-count-cpu"><em>Efficiency Assessment</em></a> that
<tt class="docutils literal"><span class="pre">dna.count(base)</span></tt> was much faster than the various manual
implementations of counting, we can write a faster and simpler
function for computing all the base frequencies:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">get_base_frequencies_v2</span><span class="p">(</span><span class="n">dna</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">base</span><span class="p">:</span> <span class="n">dna</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">base</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dna</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="s">&#39;ATGC&#39;</span><span class="p">}</span>
</pre></div>
</div>
<p>A little test,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dna</span> <span class="o">=</span> <span class="s">&#39;ACCAGAGT&#39;</span>
<span class="n">frequencies</span> <span class="o">=</span> <span class="n">get_base_frequencies_v2</span><span class="p">(</span><span class="n">dna</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">format_frequencies</span><span class="p">(</span><span class="n">frequencies</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">: </span><span class="si">%.2f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">[</span><span class="n">base</span><span class="p">])</span>
                      <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">frequencies</span><span class="p">])</span>

<span class="k">print</span> <span class="s">&quot;Base frequencies of sequence &#39;</span><span class="si">%s</span><span class="s">&#39;:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> \
      <span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="n">format_frequencies</span><span class="p">(</span><span class="n">frequencies</span><span class="p">))</span>
</pre></div>
</div>
<p>gives the result</p>
<div class="highlight-text"><div class="highlight"><pre>Base frequencies of sequence &#39;ACCAGAGT&#39;:
A: 0.38, C: 0.25, T: 0.12, G: 0.25
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">format_frequencies</span></tt> function was made for nice printout of
the frequencies with 2 decimals. The one-line code is an effective
combination of a dictionary, list comprehension, and the
<tt class="docutils literal"><span class="pre">join</span></tt> functionality. The latter is used to get a comma correctly
inserted between the items in the result. Lazy programmers would
probably just do a <tt class="docutils literal"><span class="pre">print</span> <span class="pre">frequencies</span></tt> and live with the
curly braces in the output and (in general) 16 disturbing decimals.</p>
<p id="index-21">We can try the frequency computation on real data. The file</p>
<div class="highlight-text"><div class="highlight"><pre>http://hplgit.github.com/bioinf-py/data/yeast_chr1.txt
</pre></div>
</div>
<p>contains the DNA for yeast. We can download this file from
the Internet by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">urllib</span><span class="o">.</span><span class="n">urlretrieve</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">name_of_local_file</span><span class="p">)</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">url</span></tt> is the Internet address of the file and <tt class="docutils literal"><span class="pre">name_of_local_file</span></tt>
is a string containing the name of the file on the computer where the
file is downloaded.
To avoid repeated downloads when the program is run multiple times,
we insert a test on whether the local file exists or not. The
call <tt class="docutils literal"><span class="pre">os.path.isfile(f)</span></tt> returns <tt class="docutils literal"><span class="pre">True</span></tt> if a file with name <tt class="docutils literal"><span class="pre">f</span></tt> exists
in the current working folder.</p>
<p>The appropriate download code then becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">urllib</span><span class="o">,</span> <span class="nn">os</span>
<span class="n">urlbase</span> <span class="o">=</span> <span class="s">&#39;http://hplgit.github.com/bioinf-py/data/&#39;</span>
<span class="n">yeast_file</span> <span class="o">=</span> <span class="s">&#39;yeast_chr1.txt&#39;</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">yeast_file</span><span class="p">):</span>
    <span class="n">url</span> <span class="o">=</span> <span class="n">urlbase</span> <span class="o">+</span> <span class="n">yeast_file</span>
    <span class="n">urllib</span><span class="o">.</span><span class="n">urlretrieve</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">yeast_file</span><span class="p">)</span>
</pre></div>
</div>
<p>A copy of the file on the Internet is now in the current working folder
under the name <tt class="docutils literal"><span class="pre">yeast_chr1.txt</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">yeast_chr1.txt</span></tt> files contains the DNA string split over many lines.
We therefore need to read the lines in this file, strip each line to
remove the trailing newline, and join all the stripped lines to
recover the DNA string:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">read_dnafile_v1</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
    <span class="c"># Remove newlines in each line (line.strip()) and join</span>
    <span class="n">dna</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">dna</span>
</pre></div>
</div>
<p>As usual, an alternative programming solution can be devised:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">read_dnafile_v2</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="n">dna</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">):</span>
        <span class="n">dna</span> <span class="o">+=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">dna</span>

<span class="n">dna</span> <span class="o">=</span> <span class="n">read_dnafile_v2</span><span class="p">(</span><span class="n">yeast_file</span><span class="p">)</span>
<span class="n">yeast_freq</span> <span class="o">=</span> <span class="n">get_base_frequencies_v2</span><span class="p">(</span><span class="n">dna</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;Base frequencies of yeast DNA (length </span><span class="si">%d</span><span class="s">):</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> \
      <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dna</span><span class="p">),</span> <span class="n">format_frequencies</span><span class="p">(</span><span class="n">yeast_freq</span><span class="p">))</span>
</pre></div>
</div>
<p>The output becomes</p>
<div class="highlight-text"><div class="highlight"><pre>Base frequencies of yeast DNA (length 230208):
A: 0.30, C: 0.19, T: 0.30, G: 0.20
</pre></div>
</div>
<p>The varying frequency of different nucleotides in DNA is referred to
as nucleotide bias. The nucleotide bias varies between organisms, and
have a range of biological implications. For many organisms the
nucleotide bias has been highly optimized through evolution and
reflects characteristics of the organisms and their environments, for
instance the typical temperature the organism is adapted to.
The
interested reader can, e.g., find more details in
<a class="reference external" href="http://www.nature.com/embor/journal/v6/n12/full/7400538.html">this article</a>.</p>
<p>The functions computing base frequencies are available
in the file <a class="reference external" href="http://tinyurl.com/q4qpjbt/basefreq.py">basefreq.py</a>.</p>
</div>
<div class="section" id="translating-genes-into-proteins">
<span id="bioinf-gene2protein"></span><h2>Translating Genes into Proteins<a class="headerlink" href="#translating-genes-into-proteins" title="Permalink to this headline">¶</a></h2>
<p>An important usage of DNA is for cells to store information on their
arsenal of proteins. Briefly, a gene is, in essence, a region of the
DNA, consisting of several coding parts (called exons), interspersed
by non-coding parts (called introns).  The coding parts are
concatenated to form a string called mRNA, where also occurrences of
the letter T in the coding parts are substituted by a U. A triplet of
mRNA letters code for a specific amino acid, which are the building
blocks of proteins. Consecutive triplets of letters in mRNA define a
specific sequence of amino acids, which amounts to a certain protein.</p>
<p>Here is an example of using the mapping from DNA to proteins to create
the Lactase protein (LPH), using the DNA sequence of the Lactase gene
(LCT) as underlying code. An important functional property of LPH is
in digesting Lactose, which is found most notably in milk. Lack of the
functionality of LPH leads to digestive problems referred to as
lactose intolerance. Most mammals and humans lose their expression of
LCT and therefore their ability to digest milk when they stop
receiving breast milk.</p>
<p>The file</p>
<div class="highlight-text"><div class="highlight"><pre>http://hplgit.github.com/bioinf-py/doc/src/data/genetic_code.tsv
</pre></div>
</div>
<p>contains a mapping of genetic codes to amino acids.
The file format looks like</p>
<div class="highlight-text"><div class="highlight"><pre>UUU     F       Phe     Phenylalanine
UUC     F       Phe     Phenylalanine
UUA     L       Leu     Leucine
UUG     L       Leu     Leucine
CUU     L       Leu     Leucine
CUC     L       Leu     Leucine
CUA     L       Leu     Leucine
CUG     L       Leu     Leucine
AUU     I       Ile     Isoleucine
AUC     I       Ile     Isoleucine
AUA     I       Ile     Isoleucine
AUG     M       Met     Methionine (Start)
</pre></div>
</div>
<p>The first column is the genetic code (triplet in mRNA),
while the other columns represent
various ways of expressing the corresponding amino acid:
a 1-letter symbol, a 3-letter name, and the full name.</p>
<p>Downloading the <tt class="docutils literal"><span class="pre">genetic_code.tsv</span></tt> file can be done by
this robust function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">download</span><span class="p">(</span><span class="n">urlbase</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
        <span class="n">url</span> <span class="o">=</span> <span class="n">urlbase</span> <span class="o">+</span> <span class="n">filename</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">urllib</span><span class="o">.</span><span class="n">urlretrieve</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IOError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s">&#39;No Internet connection&#39;</span><span class="p">)</span>
        <span class="c"># Check if downloaded file is an HTML file, which</span>
        <span class="c"># is what github.com returns if the URL is not existing</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">&#39;DOCTYPE html&#39;</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s">&#39;URL </span><span class="si">%s</span><span class="s"> does not exist&#39;</span> <span class="o">%</span> <span class="n">url</span><span class="p">)</span>
</pre></div>
</div>
<p>We want to make a dictionary of this file that maps the code (first
column) on to the 1-letter name (second column):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">read_genetic_code_v1</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="n">infile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
    <span class="n">genetic_code</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">infile</span><span class="p">:</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="n">genetic_code</span><span class="p">[</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">genetic_code</span>
</pre></div>
</div>
<p>Downloading the file, reading it, and making the dictionary are done
by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">urlbase</span> <span class="o">=</span> <span class="s">&#39;http://hplgit.github.com/bioinf-py/data/&#39;</span>
<span class="n">genetic_code_file</span> <span class="o">=</span> <span class="s">&#39;genetic_code.tsv&#39;</span>
<span class="n">download</span><span class="p">(</span><span class="n">urlbase</span><span class="p">,</span> <span class="n">genetic_code_file</span><span class="p">)</span>
<span class="n">code</span> <span class="o">=</span> <span class="n">read_genetic_code_v1</span><span class="p">(</span><span class="n">genetic_code_file</span><span class="p">)</span>
</pre></div>
</div>
<p>Not surprisingly, the <tt class="docutils literal"><span class="pre">read_genetic_code_v1</span></tt> can be made much shorter
by collecting the first two columns as list of 2-lists and then
converting the 2-lists to key-value pairs in a dictionary:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">read_genetic_code_v2</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">([</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)])</span>
</pre></div>
</div>
<p>Creating a mapping of the code onto all the three variants of the amino
acid name is
also of interest. For example, we would like to make look ups like
<tt class="docutils literal"><span class="pre">['CUU']['3-letter']</span></tt> or <tt class="docutils literal"><span class="pre">['CUU']['amino</span> <span class="pre">acid']</span></tt>. This requires
a dictionary of dictionaries:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">read_genetic_code_v3</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="n">genetic_code</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">):</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="n">genetic_code</span><span class="p">[</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">genetic_code</span><span class="p">[</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s">&#39;1-letter&#39;</span><span class="p">]</span>   <span class="o">=</span> <span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">genetic_code</span><span class="p">[</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s">&#39;3-letter&#39;</span><span class="p">]</span>   <span class="o">=</span> <span class="n">columns</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">genetic_code</span><span class="p">[</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s">&#39;amino acid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">columns</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">genetic_code</span>
</pre></div>
</div>
<p>An alternative way of writing the last function is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">read_genetic_code_v4</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="n">genetic_code</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="n">genetic_code</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">&#39;1-letter&#39;</span><span class="p">:</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&#39;3-letter&#39;</span><span class="p">:</span> <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s">&#39;amino acid&#39;</span><span class="p">:</span> <span class="n">c</span><span class="p">[</span><span class="mi">3</span><span class="p">]}</span>
    <span class="k">return</span> <span class="n">genetic_code</span>
</pre></div>
</div>
<p>To form mRNA, we need to grab the exon regions (the coding parts) of
the lactase gene.  These regions are substrings of the lactase gene
DNA string, corresponding to the start and end positions of the exon
regions.  Then we must replace T by U, and combine all the substrings
to build the mRNA string.</p>
<p>Two straightforward subtasks are to load the lactase gene and its exon
positions into variables.  The file <tt class="docutils literal"><span class="pre">lactase_gene.txt</span></tt>, at the same
Internet location as the other files, stores the lactase gene. The file
has the same format as <tt class="docutils literal"><span class="pre">yeast_chr1.txt</span></tt>. Using the <tt class="docutils literal"><span class="pre">download</span></tt> function
and the previously shown <tt class="docutils literal"><span class="pre">read_dnafile_v1</span></tt>, we can easily load the
data in the file into the string <tt class="docutils literal"><span class="pre">lactase_gene</span></tt>.</p>
<p>The exon regions are described in a file <tt class="docutils literal"><span class="pre">lactase_exon.tsv</span></tt>, also
found at the same Internet site as the other files. The file is easily
transferred to your computer by calling <tt class="docutils literal"><span class="pre">download</span></tt>.  The file format
is very simple in that each line holds the start and end positions of
an exon region:</p>
<div class="highlight-text"><div class="highlight"><pre>0       651
3990    4070
7504    7588
13177   13280
15082   15161
</pre></div>
</div>
<p>We want to have this information available in a list of (start, end)
tuples. The following function does the job:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">read_exon_regions_v1</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="n">positions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">infile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">infile</span><span class="p">:</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
        <span class="n">positions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
    <span class="n">infile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">positions</span>
</pre></div>
</div>
<p>Readers favoring compact code will appreciate this alternative version
of the function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">read_exon_regions_v2</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)]</span>

<span class="n">lactase_exon_regions</span> <span class="o">=</span> <span class="n">read_exon_regions_v2</span><span class="p">(</span><span class="n">lactase_exon_file</span><span class="p">)</span>
</pre></div>
</div>
<p>For simplicity&#8217;s sake, we shall consider mRNA as the concatenation of exons,
although in reality, additional base pairs are added to each end.
Having the lactase gene as a string and the exon regions as a list of
(start, end) tuples, it is straightforward to extract the regions
as substrings, replace T by U, and add all the substrings together:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">create_mRNA</span><span class="p">(</span><span class="n">gene</span><span class="p">,</span> <span class="n">exon_regions</span><span class="p">):</span>
    <span class="n">mrna</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
    <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">exon_regions</span><span class="p">:</span>
        <span class="n">mrna</span> <span class="o">+=</span> <span class="n">gene</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;T&#39;</span><span class="p">,</span><span class="s">&#39;U&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mrna</span>

<span class="n">mrna</span> <span class="o">=</span> <span class="n">create_mRNA</span><span class="p">(</span><span class="n">lactase_gene</span><span class="p">,</span> <span class="n">lactase_exon_regions</span><span class="p">)</span>
</pre></div>
</div>
<p>We would like to store the mRNA string in a file, using the same
format as <tt class="docutils literal"><span class="pre">lactase_gene.txt</span></tt> and <tt class="docutils literal"><span class="pre">yeast_chr1.txt</span></tt>, i.e.,
the string is split on multiple lines with, e.g., 70 characters per line.
An appropriate function doing this is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">tofile_with_line_sep_v1</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">chars_per_line</span><span class="o">=</span><span class="mi">70</span><span class="p">):</span>
    <span class="n">outfile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">),</span> <span class="n">chars_per_line</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">chars_per_line</span>
        <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
    <span class="n">outfile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>It might be convenient to have a separate folder for files that we create.
Python has good support for testing if a folder exists, and if not,
make a folder:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">output_folder</span> <span class="o">=</span> <span class="s">&#39;output&#39;</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">output_folder</span><span class="p">):</span>
    <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">output_folder</span><span class="p">)</span>
<span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_folder</span><span class="p">,</span> <span class="s">&#39;lactase_mrna.txt&#39;</span><span class="p">)</span>
<span class="n">tofile_with_line_sep_v1</span><span class="p">(</span><span class="n">mrna</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
</pre></div>
</div>
<p>Python&#8217;s term for folder is directory, which explains why <tt class="docutils literal"><span class="pre">isdir</span></tt> is
the function name for testing on a folder existence. Observe
especially that the combination of a folder and a filename is done via
<tt class="docutils literal"><span class="pre">os.path.join</span></tt> rather than just inserting a forward slash, or backward
slash on Windows: <tt class="docutils literal"><span class="pre">os.path.join</span></tt> will insert the right slash, forward
or backward, depending on the current operating system.</p>
<p>Occasionally, the output folder is nested, say</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">output_folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s">&#39;output&#39;</span><span class="p">,</span> <span class="s">&#39;lactase&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>In that case, <tt class="docutils literal"><span class="pre">os.mkdir(output_folder)</span></tt> may fail because the
intermediate folder <tt class="docutils literal"><span class="pre">output</span></tt> is missing. Making a folder and also all
missing intermediate folders is done by <tt class="docutils literal"><span class="pre">os.makedirs</span></tt>.  We can write a
more general file writing function that takes a folder name and file
name as input and writes the file.  Let us also add some flexibility
in the file format: one can either write a fixed number of characters
per line, or have the string on just one long line. The latter version
is specified through <tt class="docutils literal"><span class="pre">chars_per_line='inf'</span></tt> (for infinite number of
characters per line).  The flexible file writing function then becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">tofile_with_line_sep_v2</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">foldername</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span>
                            <span class="n">chars_per_line</span><span class="o">=</span><span class="mi">70</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">foldername</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">foldername</span><span class="p">)</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">foldername</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
    <span class="n">outfile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">chars_per_line</span> <span class="o">==</span> <span class="s">&#39;inf&#39;</span><span class="p">:</span>
        <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">),</span> <span class="n">chars_per_line</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">chars_per_line</span>
            <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
    <span class="n">outfile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>To create the protein, we replace the triplets of the mRNA strings
by the corresponding 1-letter name as specified in the
<tt class="docutils literal"><span class="pre">genetic_code.tsv</span></tt> file.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">create_protein</span><span class="p">(</span><span class="n">mrna</span><span class="p">,</span> <span class="n">genetic_code</span><span class="p">):</span>
    <span class="n">protein</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mrna</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">3</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">3</span>
        <span class="n">protein</span> <span class="o">+=</span> <span class="n">genetic_code</span><span class="p">[</span><span class="n">mrna</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">protein</span>

<span class="n">genetic_code</span> <span class="o">=</span> <span class="n">read_genetic_code_v1</span><span class="p">(</span><span class="s">&#39;genetic_code.tsv&#39;</span><span class="p">)</span>
<span class="n">protein</span> <span class="o">=</span> <span class="n">create_protein</span><span class="p">(</span><span class="n">mrna</span><span class="p">,</span> <span class="n">genetic_code</span><span class="p">)</span>
<span class="n">tofile_with_line_sep_v2</span><span class="p">(</span><span class="n">protein</span><span class="p">,</span> <span class="s">&#39;output&#39;</span><span class="p">,</span>
</pre></div>
</div>
<p>Unfortunately, this first try to simulate the translation process is
incorrect. The problem is that the translation always begins with the
amino acid Methionine, code AUG, and ends when one of the stop codons
is met. We must thus check for the correct start and stop criteria.
A fix is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">create_protein_fixed</span><span class="p">(</span><span class="n">mrna</span><span class="p">,</span> <span class="n">genetic_code</span><span class="p">):</span>
    <span class="n">protein_fixed</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
    <span class="n">trans_start_pos</span> <span class="o">=</span> <span class="n">mrna</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#39;AUG&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mrna</span><span class="p">[</span><span class="n">trans_start_pos</span><span class="p">:])</span><span class="o">/</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">trans_start_pos</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="mi">3</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">3</span>
        <span class="n">amino</span> <span class="o">=</span> <span class="n">genetic_code</span><span class="p">[</span><span class="n">mrna</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">amino</span> <span class="o">==</span> <span class="s">&#39;X&#39;</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">protein_fixed</span> <span class="o">+=</span> <span class="n">amino</span>
    <span class="k">return</span> <span class="n">protein_fixed</span>

<span class="n">protein</span> <span class="o">=</span> <span class="n">create_protein_fixed</span><span class="p">(</span><span class="n">mrna</span><span class="p">,</span> <span class="n">genetic_code</span><span class="p">)</span>
<span class="n">tofile_with_line_sep_v2</span><span class="p">(</span><span class="n">protein</span><span class="p">,</span> <span class="s">&#39;output&#39;</span><span class="p">,</span>
                        <span class="s">&#39;lactase_protein_fixed.txt&#39;</span><span class="p">,</span> <span class="mi">70</span><span class="p">)</span>

<span class="k">print</span> <span class="s">&#39;10 last amino acids of the correct lactase protein: &#39;</span><span class="p">,</span> \
      <span class="n">protein</span><span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">:]</span>
<span class="k">print</span> <span class="s">&#39;Lenght of the correct protein: &#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">protein</span><span class="p">)</span>
</pre></div>
</div>
<p>The output, needed below for comparison, becomes</p>
<div class="highlight-text"><div class="highlight"><pre>10 last amino acids of the correct lactase protein:  QQELSPVSSF
Lenght of the correct protein:  1927
</pre></div>
</div>
</div>
<div class="section" id="some-humans-can-drink-milk-while-others-cannot">
<span id="bioinf-lactase-milk"></span><h2>Some Humans Can Drink Milk, While Others Cannot<a class="headerlink" href="#some-humans-can-drink-milk-while-others-cannot" title="Permalink to this headline">¶</a></h2>
<p>One type of lactose intolerance is called <em>Congenital lactase deficiency</em>.
This is a rare genetic disorder that causes lactose intolerance from birth,
and is particularly common in Finland. The disease is caused by a mutation of
the base in position 30049 (0-based) of the lactase gene, a mutation from T to
A. Our goal is to check what happens to the protein if this base is mutated.
This is a simple task using the previously developed tools:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">congential_lactase_deficiency</span><span class="p">(</span>
    <span class="n">lactase_gene</span><span class="p">,</span>
    <span class="n">genetic_code</span><span class="p">,</span>
    <span class="n">lactase_exon_regions</span><span class="p">,</span>
    <span class="n">output_folder</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">curdir</span><span class="p">,</span>
    <span class="n">mrna_file</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
    <span class="n">protein_file</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>

    <span class="n">pos</span> <span class="o">=</span> <span class="mi">30049</span>
    <span class="n">mutated_gene</span> <span class="o">=</span> <span class="n">lactase_gene</span><span class="p">[:</span><span class="n">pos</span><span class="p">]</span> <span class="o">+</span> <span class="s">&#39;A&#39;</span> <span class="o">+</span> <span class="n">lactase_gene</span><span class="p">[</span><span class="n">pos</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">mutated_mrna</span> <span class="o">=</span> <span class="n">create_mRNA</span><span class="p">(</span><span class="n">mutated_gene</span><span class="p">,</span> <span class="n">lactase_exon_regions</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mrna_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">tofile_with_line_sep_v2</span><span class="p">(</span>
            <span class="n">mutated_mrna</span><span class="p">,</span> <span class="n">output_folder</span><span class="p">,</span> <span class="n">mrna_file</span><span class="p">)</span>

    <span class="n">mutated_protein</span> <span class="o">=</span> <span class="n">create_protein_fixed</span><span class="p">(</span>
        <span class="n">mutated_mrna</span><span class="p">,</span> <span class="n">genetic_code</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">protein_file</span><span class="p">:</span>
        <span class="n">tofile_with_line_sep_v2</span><span class="p">(</span>
            <span class="n">mutated_protein</span><span class="p">,</span> <span class="n">output_folder</span><span class="p">,</span> <span class="n">protein_file</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mutated_protein</span>

<span class="n">mutated_protein</span> <span class="o">=</span> <span class="n">congential_lactase_deficiency</span><span class="p">(</span>
    <span class="n">lactase_gene</span><span class="p">,</span> <span class="n">genetic_code</span><span class="p">,</span> <span class="n">lactase_exon_regions</span><span class="p">,</span>
    <span class="n">output_folder</span><span class="o">=</span><span class="s">&#39;output&#39;</span><span class="p">,</span>
    <span class="n">mrna_file</span><span class="o">=</span><span class="s">&#39;mutated_lactase_mrna.txt&#39;</span><span class="p">,</span>
    <span class="n">protein_file</span><span class="o">=</span><span class="s">&#39;mutated_lactase_protein.txt&#39;</span><span class="p">)</span>

<span class="k">print</span> <span class="s">&#39;10 last amino acids of the mutated lactase protein:&#39;</span><span class="p">,</span> \
      <span class="n">mutated_protein</span><span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">:]</span>
<span class="k">print</span> <span class="s">&#39;Lenght of the mutated lactase protein:&#39;</span><span class="p">,</span> \
      <span class="nb">len</span><span class="p">(</span><span class="n">mutated_protein</span><span class="p">)</span>
</pre></div>
</div>
<p>The output, to be compared with the non-mutated gene above, is now</p>
<div class="highlight-text"><div class="highlight"><pre>10 last amino acids of the mutated lactase protein: GFIWSAASAA
Lenght of the mutated lactase protein: 1389
</pre></div>
</div>
<p>As we can see, the translation stops prematurely, creating a much smaller
protein, which will not have the required characteristics of the lactase
protein.</p>
<p>A couple of mutations in a region for LCT located in front of LCT (actually in
the introns of another gene) is the reason for the common lactose intolerance.
That is, the one that sets in for adults only. These mutations control the
expression of the LCT gene, i.e., whether that the gene is turned on or off.
Interestingly, different mutations have evolved in different regions of the
world, e.g., Africa and Northern Europe. This is an example of convergent
evolution: the acquisition of the same biological trait in unrelated
lineages. The prevalence of lactose intolerance varies widely, from around 5%
in northern Europe, to close to 100% in south-east Asia.</p>
<p>The functions analyzing the lactase gene are found
in the file <a class="reference external" href="http://tinyurl.com/q4qpjbt/genes2proteins.py">genes2proteins.py</a>.</p>
</div>
<div class="section" id="random-mutations-of-genes">
<span id="bioinf-random"></span><h2>Random Mutations of Genes<a class="headerlink" href="#random-mutations-of-genes" title="Permalink to this headline">¶</a></h2>
<div class="section" id="a-simple-mutation-model">
<h3>A Simple Mutation Model<a class="headerlink" href="#a-simple-mutation-model" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>Mutation of genes</div></blockquote>
<p>is easily modeled by replacing the letter in a randomly
chosen position of the DNA by a randomly chosen letter from
the alphabet A, C, G, and T.
Python&#8217;s <tt class="docutils literal"><span class="pre">random</span></tt> module can be used
to generate random numbers. Selecting a random position means
generating a random index in the DNA string, and the function
<tt class="docutils literal"><span class="pre">random.randint(a,</span> <span class="pre">b)</span></tt> generates random integers between <tt class="docutils literal"><span class="pre">a</span></tt> and
<tt class="docutils literal"><span class="pre">b</span></tt> (both included). Generating a random
letter is easiest done by having a list of the actual letters
and using <tt class="docutils literal"><span class="pre">random.choice(list)</span></tt> to pick an arbitrary element from
<tt class="docutils literal"><span class="pre">list</span></tt>. A function for replacing the letter in a
randomly selected position (index)
by a random letter among A, C, G, and T is most straightforwardly
implemented by converting the DNA string to a list of letters, since
changing a character in a Python string is impossible without
constructing a new string. However, an element in a list can be
changed in-place:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">random</span>

<span class="k">def</span> <span class="nf">mutate_v1</span><span class="p">(</span><span class="n">dna</span><span class="p">):</span>
    <span class="n">dna_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dna</span><span class="p">)</span>
    <span class="n">mutation_site</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dna_list</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">dna_list</span><span class="p">[</span><span class="n">mutation_site</span><span class="p">]</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="s">&#39;ATCG&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dna_list</span><span class="p">)</span>
</pre></div>
</div>
<p>Using <tt class="docutils literal"><span class="pre">get_base_frequencies_v2</span></tt> and <tt class="docutils literal"><span class="pre">format_frequencies</span></tt>
from the section <a class="reference internal" href="#bioinf-basefreq"><em>Finding Base Frequencies</em></a>, we can easily mutate a gene a number
of times and see how the frequencies of the bases A, C, G, and T change:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dna</span> <span class="o">=</span> <span class="s">&#39;ACGGAGATTTCGGTATGCAT&#39;</span>
<span class="k">print</span> <span class="s">&#39;Starting DNA:&#39;</span><span class="p">,</span> <span class="n">dna</span>
<span class="k">print</span> <span class="n">format_frequencies</span><span class="p">(</span><span class="n">get_base_frequencies_v2</span><span class="p">(</span><span class="n">dna</span><span class="p">))</span>

<span class="n">nmutations</span> <span class="o">=</span> <span class="mi">10000</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmutations</span><span class="p">):</span>
    <span class="n">dna</span> <span class="o">=</span> <span class="n">mutate_v1</span><span class="p">(</span><span class="n">dna</span><span class="p">)</span>

<span class="k">print</span> <span class="s">&#39;DNA after </span><span class="si">%d</span><span class="s"> mutations:&#39;</span> <span class="o">%</span> <span class="n">nmutations</span><span class="p">,</span> <span class="n">dna</span>
<span class="k">print</span> <span class="n">format_frequencies</span><span class="p">(</span><span class="n">get_base_frequencies_v2</span><span class="p">(</span><span class="n">dna</span><span class="p">))</span>
</pre></div>
</div>
<p>Here is the output from a run:</p>
<div class="highlight-text"><div class="highlight"><pre>Starting DNA: ACGGAGATTTCGGTATGCAT
A: 0.25, C: 0.15, T: 0.30, G: 0.30
DNA after 10000 mutations: AACCAATCCGACGAGGAGTG
A: 0.35, C: 0.25, T: 0.10, G: 0.30
</pre></div>
</div>
</div>
<div class="section" id="vectorized-version">
<h3>Vectorized Version<a class="headerlink" href="#vectorized-version" title="Permalink to this headline">¶</a></h3>
<p>The efficiency of the <tt class="docutils literal"><span class="pre">mutate_v1</span></tt> function with its surrounding loop can be
significantly increased up by performing all the mutations at
once using <tt class="docutils literal"><span class="pre">numpy</span></tt> arrays. This speed-up is of interest for long <tt class="docutils literal"><span class="pre">dna</span></tt>
strings and many mutations. The idea is to draw all the mutation sites
at once, and also all the new bases at these sites at once.
The <tt class="docutils literal"><span class="pre">np.random</span></tt> module provides functions for drawing several random
numbers at a time, but only integers and real numbers can be drawn,
not characters from the alphabet A, C, G, and T. We therefore have
to simulate these four characters by the numbers (say) 0, 1, 2, and 3.
Afterwards we can translate the integers to letters by some clever
vectorized indexing.</p>
<p>Drawing <tt class="docutils literal"><span class="pre">N</span></tt> mutation sites is a matter of drawing <tt class="docutils literal"><span class="pre">N</span></tt> random
integers among the legal indices:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="n">mutation_sites</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_integers</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dna</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>
</pre></div>
</div>
<p>Drawing <tt class="docutils literal"><span class="pre">N</span></tt> bases, represented as the integers 0-3, is similarly done by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">new_bases_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_integers</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
</pre></div>
</div>
<p>Converting say the integers 1 to the base symbol C is done by
picking out the indices (in a boolean array) where <tt class="docutils literal"><span class="pre">new_bases_i</span></tt>
equals 1, and inserting the character <tt class="docutils literal"><span class="pre">'C'</span></tt> in a companion
array of characters:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">new_bases_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">)</span>
<span class="n">indices</span> <span class="o">=</span> <span class="n">new_bases_i</span> <span class="o">==</span> <span class="mi">1</span>
<span class="n">new_bases_c</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;C&#39;</span>
</pre></div>
</div>
<p>We must do this integer-to-letter conversion for all four integers/letters.
Thereafter, <tt class="docutils literal"><span class="pre">new_bases_c</span></tt> must be inserted in <tt class="docutils literal"><span class="pre">dna</span></tt> for all the
indices corresponding to the randomly drawn mutation sites,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dna</span><span class="p">[</span><span class="n">mutation_sites</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_bases_c</span>
</pre></div>
</div>
<p>The final step is to convert the <tt class="docutils literal"><span class="pre">numpy</span></tt> array of characters <tt class="docutils literal"><span class="pre">dna</span></tt>
back to a standard string by first converting <tt class="docutils literal"><span class="pre">dna</span></tt> to a list
and then joining the list elements: <tt class="docutils literal"><span class="pre">''.join(dna.tolist())</span></tt>.</p>
<p>The complete vectorized functions can now be expressed as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="c"># Use integers in random numpy arrays and map these</span>
<span class="c"># to characters according to</span>
<span class="n">i2c</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s">&#39;G&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="s">&#39;T&#39;</span><span class="p">}</span>

<span class="k">def</span> <span class="nf">mutate_v2</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="n">dna</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">)</span>  <span class="c"># array of characters</span>
    <span class="n">mutation_sites</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_integers</span><span class="p">(</span>
        <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dna</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>
    <span class="c"># Must draw bases as integers</span>
    <span class="n">new_bases_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_integers</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>
    <span class="c"># Translate integers to characters</span>
    <span class="n">new_bases_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">i2c</span><span class="p">:</span>
        <span class="n">new_bases_c</span><span class="p">[</span><span class="n">new_bases_i</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i2c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">dna</span><span class="p">[</span><span class="n">mutation_sites</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_bases_c</span>
    <span class="k">return</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dna</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
</pre></div>
</div>
<p>It is of interest to time <tt class="docutils literal"><span class="pre">mutate_v2</span></tt> versus <tt class="docutils literal"><span class="pre">mutate_v1</span></tt>. For this purpose
we need a long test string. A straightforward generation of random
letters is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">generate_string_v1</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">alphabet</span><span class="o">=</span><span class="s">&#39;ACGT&#39;</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">alphabet</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">N</span><span class="p">)])</span>
</pre></div>
</div>
<p>A vectorized version of this function can also be made, using the
ideas explored above for the <tt class="docutils literal"><span class="pre">mutate_v2</span></tt> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">generate_string_v2</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">alphabet</span><span class="o">=</span><span class="s">&#39;ACGT&#39;</span><span class="p">):</span>
    <span class="c"># Draw random integers 0,1,2,3 to represent bases</span>
    <span class="n">dna_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_integers</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="c"># Translate integers to characters</span>
    <span class="n">dna</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">i2c</span><span class="p">:</span>
        <span class="n">dna</span><span class="p">[</span><span class="n">dna_i</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i2c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dna</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">time_mutate</span></tt> function in the file <a class="reference external" href="http://tinyurl.com/q4qpjbt/mutate.py">mutate.py</a> performs
timing of the generation of test strings and the mutations.  To
generate a DNA string of length 100,000 the vectorized function is
about 8 times faster. When performing 10,000 mutations on this string,
the vectorized version is almost 3000 times faster! These numbers stay
approximately the same also for larger strings and more mutations.
Hence, this case study on vectorization is a striking example on the fact
that a straightforward and convenient function like <tt class="docutils literal"><span class="pre">mutate_v1</span></tt> might
occasionally be very slow for large-scale computations.</p>
</div>
<div class="section" id="a-markov-chain-mutation-model">
<h3>A Markov Chain Mutation Model<a class="headerlink" href="#a-markov-chain-mutation-model" title="Permalink to this headline">¶</a></h3>
<p>The observed rate at which mutations occur at a given position in the
genome is not independent of the type of nucleotide (base) at that
position, as was assumed in the previous simple mutation model.  We
should therefore take into account that the rate of transition depends
on the base.</p>
<p>There are a number of reasons why the observed mutation rates vary
between different nucleotides. One reason is that there are different
mechanisms generating transitions from one base to another. Another
reason is that there are extensive repair process in living cells, and
the efficiency of this repair mechanism varies for different
nucleotides.</p>
<p>Mutation of nucleotides may be modeled using distinct probabilities
for the transitions from each nucleotide to every other
nucleotide. For example, the probability of replacing A by C may be
prescribed as (say) 0.2. In total we need <span class="math">\(4\times 4\)</span>
probabilities since each nucleotide can transform into itself (no
change) or three others. The sum of all four transition probabilities
for a given nucleotide must sum up to one. Such statistical evolution,
based on probabilities for transitioning from one state to another, is
known as a Markov process or Markov chain.</p>
<p>First we need to set up the probability matrix, i.e., the
<span class="math">\(4\times4\)</span> table of probabilities where each row corresponds to the
transition of A, C, G, or T into A, C, G, or T. Say the probability
transition from A to A is 0.2, from A to C is 0.1, from A to G is 0.3,
and from A to T is 0.4.</p>
<p>Rather than just prescribing some arbitrary transition probabilities
for test purposes, we can use random numbers for these probabilities.
To this end, we generate three random numbers to divide the interval
<span class="math">\([0,1]\)</span> into four intervals corresponding to the four possible
transitions.  The lengths of the intervals give the transition
probabilities, and their sum is ensured to be 1.  The interval limits,
0, 1, and three random numbers must be sorted in ascending order to
form the intervals. We use the function <tt class="docutils literal"><span class="pre">random.random()</span></tt> to generate
random numbers in <span class="math">\([0,1)\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">slice_points</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">transition_probabilities</span> <span class="o">=</span> <span class="p">[</span><span class="n">slice_points</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">slice_points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>
</pre></div>
</div>
<p>The transition probabilities are handy to have available as a dictionary:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">markov_chain</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="o">...</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">:</span> <span class="o">...</span><span class="p">,</span> <span class="s">&#39;G&#39;</span><span class="p">:</span> <span class="o">...</span><span class="p">,</span> <span class="s">&#39;T&#39;</span><span class="p">:</span> <span class="o">...</span><span class="p">}</span>
</pre></div>
</div>
<p>which can be computed by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">markov_chain</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">base</span><span class="p">:</span> <span class="n">p</span> <span class="k">for</span> <span class="n">base</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span>
                     <span class="nb">zip</span><span class="p">(</span><span class="s">&#39;ACGT&#39;</span><span class="p">,</span> <span class="n">transition_probabilities</span><span class="p">)}</span>
</pre></div>
</div>
<p>To select a transition, we need to draw a random letter
(A, C, G, or T) according to the probabilities
<tt class="docutils literal"><span class="pre">markov_chain[b]</span></tt> where <tt class="docutils literal"><span class="pre">b</span></tt> is the base at the current position.
Actually, this is a very common operation, namely drawing a
random value from a <em>discrete probability distribution</em> (<tt class="docutils literal"><span class="pre">markov_chain[b]</span></tt>).
The natural approach is therefore write a general function for
drawing from any discrete probability distribution given as
a dictionary:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="n">discrete_probdist</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Draw random value from discrete probability distribution</span>
<span class="sd">    represented as a dict: P(x=value) = discrete_probdist[value].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Method:</span>
    <span class="c"># http://en.wikipedia.org/wiki/Pseudo-random_number_sampling</span>
    <span class="n">limit</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">discrete_probdist</span><span class="p">:</span>
        <span class="n">limit</span> <span class="o">+=</span> <span class="n">discrete_probdist</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span>
</pre></div>
</div>
<p>Basically, the algorithm divides <span class="math">\([0,1]\)</span> into intervals of lengths
equal to the probabilities of the various outcomes and checks
which interval is hit by a random variable in <span class="math">\([0,1]\)</span>. The corresponding
value is the random choice.</p>
<p>A complete function creating all the transition probabilities and
storing them in a dictionary of dictionaries takes the form</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">create_markov_chain</span><span class="p">():</span>
    <span class="n">markov_chain</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">from_base</span> <span class="ow">in</span> <span class="s">&#39;ATGC&#39;</span><span class="p">:</span>
        <span class="c"># Generate random transition probabilities by dividing</span>
        <span class="c"># [0,1] into four intervals of random length</span>
       <span class="n">slice_points</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
           <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>
       <span class="n">transition_probabilities</span> <span class="o">=</span> \
           <span class="p">[</span><span class="n">slice_points</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">slice_points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>
       <span class="n">markov_chain</span><span class="p">[</span><span class="n">from_base</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">base</span><span class="p">:</span> <span class="n">p</span> <span class="k">for</span> <span class="n">base</span><span class="p">,</span> <span class="n">p</span>
                         <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="s">&#39;ATGC&#39;</span><span class="p">,</span> <span class="n">transition_probabilities</span><span class="p">)}</span>
    <span class="k">return</span> <span class="n">markov_chain</span>

<span class="n">mc</span> <span class="o">=</span> <span class="n">create_markov_chain</span><span class="p">()</span>
<span class="k">print</span> <span class="n">mc</span>
<span class="k">print</span> <span class="n">mc</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">][</span><span class="s">&#39;T&#39;</span><span class="p">]</span> <span class="c"># probability of transition from A to T</span>
</pre></div>
</div>
<p>It is natural to develop a function for checking that the generated
probabilities are consistent. The transition from a particular base
into one of the four bases happens with probability 1, which means that
the probabilities in a row must sum up to 1:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">check_transition_probabilities</span><span class="p">(</span><span class="n">markov_chain</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">from_base</span> <span class="ow">in</span> <span class="s">&#39;ATGC&#39;</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">markov_chain</span><span class="p">[</span><span class="n">from_base</span><span class="p">][</span><span class="n">to_base</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">to_base</span> <span class="ow">in</span> <span class="s">&#39;ATGC&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">s</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1E-15</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Wrong sum: </span><span class="si">%s</span><span class="s"> for &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> \
                             <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">from_base</span><span class="p">))</span>
</pre></div>
</div>
<p>Another test is to check that <tt class="docutils literal"><span class="pre">draw</span></tt> actually draws random values
in accordance with the underlying probabilities. To this end, we draw
a large number of values, <tt class="docutils literal"><span class="pre">N</span></tt>, count the frequencies of the various values,
divide by <tt class="docutils literal"><span class="pre">N</span></tt> and compare the empirical normalized frequencies
with the probabilities:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">check_draw_approx</span><span class="p">(</span><span class="n">discrete_probdist</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">1000000</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See if draw results in frequencies approx equal to</span>
<span class="sd">    the probability distribution.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">frequencies</span> <span class="o">=</span> <span class="p">{</span><span class="n">value</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">discrete_probdist</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">discrete_probdist</span><span class="p">)</span>
        <span class="n">frequencies</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">frequencies</span><span class="p">:</span>
        <span class="n">frequencies</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">: </span><span class="si">%.4f</span><span class="s"> (exact </span><span class="si">%.4f</span><span class="s">)&#39;</span> <span class="o">%</span> \
                     <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">discrete_probdist</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
                     <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">frequencies</span><span class="p">])</span>
</pre></div>
</div>
<p>This test is only approximate, but does bring evidence to the correctness
of the implementation of the <tt class="docutils literal"><span class="pre">draw</span></tt> function.</p>
<p>A vectorized version of <tt class="docutils literal"><span class="pre">draw</span></tt> can also be made. We refer to the
source code file <a class="reference external" href="http://tinyurl.com/q4qpjbt/mutate.py">mutate.py</a>
for details (the function is relatively
complicated).</p>
<p>Now we have all the tools needed to run the Markov chain of
transitions for a randomly selected position in a DNA sequence:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">mutate_via_markov_chain</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="n">markov_chain</span><span class="p">):</span>
    <span class="n">dna_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dna</span><span class="p">)</span>
    <span class="n">mutation_site</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dna_list</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">from_base</span> <span class="o">=</span> <span class="n">dna</span><span class="p">[</span><span class="n">mutation_site</span><span class="p">]</span>
    <span class="n">to_base</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">markov_chain</span><span class="p">[</span><span class="n">from_base</span><span class="p">])</span>
    <span class="n">dna_list</span><span class="p">[</span><span class="n">mutation_site</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_base</span>
    <span class="k">return</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dna_list</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#bioinf-exer-markov-chain-eff"><em>Exercise 6: Speed up Markov chain mutation</em></a> suggests some efficiency
enhancements of simulating mutations via these functions.</p>
<p>Here is a simulation of mutations using the method based on Markov chains:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dna</span> <span class="o">=</span> <span class="s">&#39;TTACGGAGATTTCGGTATGCAT&#39;</span>
<span class="k">print</span> <span class="s">&#39;Starting DNA:&#39;</span><span class="p">,</span> <span class="n">dna</span>
<span class="k">print</span> <span class="n">format_frequencies</span><span class="p">(</span><span class="n">get_base_frequencies_v2</span><span class="p">(</span><span class="n">dna</span><span class="p">))</span>

<span class="n">mc</span> <span class="o">=</span> <span class="n">create_markov_chain</span><span class="p">()</span>
<span class="kn">import</span> <span class="nn">pprint</span>
<span class="k">print</span> <span class="s">&#39;Transition probabilities:</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="n">mc</span><span class="p">)</span>
<span class="n">nmutations</span> <span class="o">=</span> <span class="mi">10000</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmutations</span><span class="p">):</span>
    <span class="n">dna</span> <span class="o">=</span> <span class="n">mutate_via_markov_chain</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="n">mc</span><span class="p">)</span>

<span class="k">print</span> <span class="s">&#39;DNA after </span><span class="si">%d</span><span class="s"> mutations (Markov chain):&#39;</span> <span class="o">%</span> <span class="n">nmutations</span><span class="p">,</span> <span class="n">dna</span>
<span class="k">print</span> <span class="n">format_frequencies</span><span class="p">(</span><span class="n">get_base_frequencies_v2</span><span class="p">(</span><span class="n">dna</span><span class="p">))</span>
</pre></div>
</div>
<p>The output will differ each time the program is run unless
<tt class="docutils literal"><span class="pre">random.seed(i)</span></tt> is called in the beginning of the program for some
integer <tt class="docutils literal"><span class="pre">i</span></tt>. This call makes the
sequence of random numbers the same every time the program is run and
is very useful for debugging. An example on the output may look like</p>
<div class="highlight-text"><div class="highlight"><pre>Starting DNA: TTACGGAGATTTCGGTATGCAT
A: 0.23, C: 0.14, T: 0.36, G: 0.27
Transition probabilities:
{&#39;A&#39;: {&#39;A&#39;: 0.4288890546751146,
       &#39;C&#39;: 0.4219086988655296,
       &#39;G&#39;: 0.00668870644455688,
       &#39;T&#39;: 0.14251354001479888},
 &#39;C&#39;: {&#39;A&#39;: 0.24999667668640035,
       &#39;C&#39;: 0.04718309085408834,
       &#39;G&#39;: 0.6250440975238185,
       &#39;T&#39;: 0.0777761349356928},
 &#39;G&#39;: {&#39;A&#39;: 0.16022955651881965,
       &#39;C&#39;: 0.34652746609882423,
       &#39;G&#39;: 0.1328031742612512,
       &#39;T&#39;: 0.3604398031211049},
 &#39;T&#39;: {&#39;A&#39;: 0.20609823213950174,
       &#39;C&#39;: 0.17641112746655452,
       &#39;G&#39;: 0.010267621176125452,
       &#39;T&#39;: 0.6072230192178183}}
DNA after 10000 mutations (Markov chain): GGTTTAAGTCAGCTATGATTCT
A: 0.23, C: 0.14, T: 0.41, G: 0.23
</pre></div>
</div>
<p>Note that the mutated DNA should contain more nucleotides of the
type where the total probability of transitioning into that particular
nucleotide is largest. The total probability of transitioning into
a particular base can be computed by a bit a probability algebra.
Let <span class="math">\(X\)</span> be the initial base at some position in the DNA and let <span class="math">\(Y\)</span>
be the new base after mutation at this position. The probability
that <span class="math">\(P(Y=b)\)</span>, where <span class="math">\(b\)</span> is some base (A, C, G, or T), is built up
of four mutually exclusive events:</p>
<div class="math">
\[P(Y=b) = P(X=A \cup Y=b) + P(X=C \cup Y=b) +
P(X=G \cup Y=b) + P(X=T \cup Y=b)\]</div>
<p>A joint event can be expressed by the (conditional) transition
probabilities, e.g.,</p>
<div class="math">
\[P(X=A \cup Y=b) = P(Y=b | X=A) P(X=A)\]</div>
<p>leading to</p>
<div class="math">
\[P(Y=b) = \sum_{i\in\{A,C,G,T\}} P(Y=b|X=i)P(X=i)\]</div>
<p>The probabilities <span class="math">\(P(Y=b|X=i)\)</span> correspond to a column in the
transition probability matrix. If each of the initial events
<span class="math">\(P(X=i)\)</span> are equally probable, <span class="math">\(P(X=i)=1/4\)</span>, and <span class="math">\(P(Y=b)\)</span>
is then the sum of the probabilities in the column corresponding to
<span class="math">\(b\)</span>, divided by 4. We can now compute <span class="math">\(P(Y=b)\)</span> for
<span class="math">\(b\)</span> as A, C, G, and T:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">transition_into_bases</span><span class="p">(</span><span class="n">markov_chain</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">to_base</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="n">markov_chain</span><span class="p">[</span><span class="n">from_base</span><span class="p">][</span><span class="n">to_base</span><span class="p">]</span>
                         <span class="k">for</span> <span class="n">from_base</span> <span class="ow">in</span> <span class="s">&#39;ATGC&#39;</span><span class="p">)</span><span class="o">/</span><span class="mf">4.0</span>
            <span class="k">for</span> <span class="n">to_base</span> <span class="ow">in</span> <span class="s">&#39;ATGC&#39;</span><span class="p">}</span>

<span class="k">print</span> <span class="n">transition_into_bases</span><span class="p">(</span><span class="n">mc</span><span class="p">)</span>
</pre></div>
</div>
<p>The <span class="math">\(P(X=b)\)</span> probabilities corresponding to the example run above reads</p>
<div class="highlight-text"><div class="highlight"><pre>{&#39;A&#39;: 0.26, &#39;C&#39;: 0.25, &#39;T&#39;: 0.30, &#39;G&#39;: 0.19}
</pre></div>
</div>
<p>Transition into T (<span class="math">\(P(Y=T)\)</span>) has greatest probability (0.3) and this is also
confirmed by the greatest frequency (0.41).</p>
<p>The various functions performing mutations are located
in the file <a class="reference external" href="http://tinyurl.com/q4qpjbt/mutate.py">mutate.py</a>.</p>
</div>
</div>
</div>
<div class="section" id="classes-for-dna-analysis">
<span id="bioinf-oo"></span><h1>Classes for DNA Analysis<a class="headerlink" href="#classes-for-dna-analysis" title="Permalink to this headline">¶</a></h1>
<p>We shall here exemplify the use of classes for performing
DNA analysis as explained  in the previous text.
Basically, we create a class <tt class="docutils literal"><span class="pre">Gene</span></tt> to represent a DNA sequence (string)
and a class <tt class="docutils literal"><span class="pre">Region</span></tt> to represent a subsequence (substring), typically an
exon or intron.</p>
<div class="section" id="class-for-regions">
<h2>Class for Regions<a class="headerlink" href="#class-for-regions" title="Permalink to this headline">¶</a></h2>
<p>The class for representing a region of a DNA string is quite simple:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Region</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dna</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_region</span> <span class="o">=</span> <span class="n">dna</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">get_region</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_region</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_region</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if two Region instances are equal.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_region</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_region</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add Region instances: self + other&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_region</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">_region</span>

    <span class="k">def</span> <span class="nf">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Increment Region instance: self += other&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_region</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">_region</span>
        <span class="k">return</span> <span class="bp">self</span>
</pre></div>
</div>
<p>Besides storing the substring and giving access to it through <tt class="docutils literal"><span class="pre">get_region</span></tt>,
we have also included the possibility to</p>
<blockquote>
<div><ul class="simple">
<li>say <tt class="docutils literal"><span class="pre">len(r)</span></tt> if <tt class="docutils literal"><span class="pre">r</span></tt> is a <tt class="docutils literal"><span class="pre">Region</span></tt> instance</li>
<li>check if two <tt class="docutils literal"><span class="pre">Region</span></tt> instances are equal</li>
<li>write <tt class="docutils literal"><span class="pre">r1</span> <span class="pre">+</span> <span class="pre">r2</span></tt> for two instances <tt class="docutils literal"><span class="pre">r1</span></tt> and <tt class="docutils literal"><span class="pre">r2</span></tt> of type <tt class="docutils literal"><span class="pre">Region</span></tt></li>
<li>perform <tt class="docutils literal"><span class="pre">r1</span> <span class="pre">+=</span> <span class="pre">r2</span></tt></li>
</ul>
</div></blockquote>
<p>The latter two operations are convenient for making one large string out
of all exon or intron regions.</p>
</div>
<div class="section" id="class-for-genes">
<h2>Class for Genes<a class="headerlink" href="#class-for-genes" title="Permalink to this headline">¶</a></h2>
<p>The class for gene will be longer and more complex than class
<tt class="docutils literal"><span class="pre">Region</span></tt>. We already have a bunch of functions performing various
types of analysis. The idea of the <tt class="docutils literal"><span class="pre">Gene</span></tt> class is that these
functions are methods in the class operating on the DNA string and the
exon regions stored in the class.  Rather than recoding all the
functions as methods in the class we shall just let the class &#8220;wrap&#8221;
the functions. That is, the class methods call up the functions we
already have.  This approach has two advantages: users can either
choose the function-based or the class-based interface, and the
programmer can reuse all the ready-made functions when implementing
the class-based interface.</p>
<p>The selection of functions include</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">generate_string</span></tt> for generating a random string from some alphabet</li>
<li><tt class="docutils literal"><span class="pre">download</span></tt> and <tt class="docutils literal"><span class="pre">read_dnafile</span></tt>
(version <tt class="docutils literal"><span class="pre">read_dnafile_v1</span></tt>)
for downloading data from the Internet and reading from file</li>
<li><tt class="docutils literal"><span class="pre">read_exon_regions</span></tt> (version <tt class="docutils literal"><span class="pre">read_exon_regions_v2</span></tt>)
for reading exon regions from file</li>
<li><tt class="docutils literal"><span class="pre">tofile_with_line_sep</span></tt> (version <tt class="docutils literal"><span class="pre">tofile_with_line_sep_v2</span></tt>)
for writing strings to file</li>
<li><tt class="docutils literal"><span class="pre">read_genetic_code</span></tt> (version <tt class="docutils literal"><span class="pre">read_genetic_code_v2</span></tt>) for loading
the mapping from triplet codes to 1-letter symbols for amino acids</li>
<li><tt class="docutils literal"><span class="pre">get_base_frequencies</span></tt> (version <tt class="docutils literal"><span class="pre">get_base_frequencies_v2</span></tt>)
for finding frequencies of each base</li>
<li><tt class="docutils literal"><span class="pre">format_frequencies</span></tt> for formatting base frequencies with two decimals</li>
<li><tt class="docutils literal"><span class="pre">create_mRNA</span></tt> for computing an mRNA string from DNA and exon regions</li>
<li><tt class="docutils literal"><span class="pre">mutate</span></tt> for mutating a base at a random position</li>
<li><tt class="docutils literal"><span class="pre">create_markov_chain</span></tt>, <tt class="docutils literal"><span class="pre">transition</span></tt>, and <tt class="docutils literal"><span class="pre">mutate_via_markov_chain</span></tt>
for mutating a base at a random position according to randomly
generated transition probabilities</li>
<li><tt class="docutils literal"><span class="pre">create_protein_fixed</span></tt> for proper creation of a protein sequence (string)</li>
</ul>
</div></blockquote>
<p>The set of plain functions for DNA analysis is found
in the file <a class="reference external" href="http://tinyurl.com/q4qpjbt/dna_functions.py">dna_functions.py</a>, while
<a class="reference external" href="http://tinyurl.com/q4qpjbt/dna_classes.py">dna_classes.py</a> contains the implementations
of classes <tt class="docutils literal"><span class="pre">Gene</span></tt> and <tt class="docutils literal"><span class="pre">Region</span></tt>.</p>
<div class="section" id="basic-features-of-class-gene">
<h3>Basic Features of class Gene<a class="headerlink" href="#basic-features-of-class-gene" title="Permalink to this headline">¶</a></h3>
<p>Class <tt class="docutils literal"><span class="pre">Gene</span></tt> is supposed to hold the DNA sequence and
the associated exon regions. A simple constructor expects the
exon regions to be specified as a list of (start, end) tuples
indicating the start and end of each region:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Gene</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dna</span><span class="p">,</span> <span class="n">exon_regions</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dna</span> <span class="o">=</span> <span class="n">dna</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_exon_regions</span> <span class="o">=</span> <span class="n">exon_regions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">exon_regions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_exons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Region</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>

        <span class="c"># Compute the introns (regions between the exons)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_introns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">prev_end</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">exon_regions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_introns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Region</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="n">prev_end</span><span class="p">,</span> <span class="n">start</span><span class="p">))</span>
            <span class="n">prev_end</span> <span class="o">=</span> <span class="n">end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_introns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Region</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dna</span><span class="p">)))</span>
</pre></div>
</div>
<p>The methods in class <tt class="docutils literal"><span class="pre">Gene</span></tt> are trivial to implement when we already
have the functionality in stand-alone functions.
Here are a few examples on methods:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">dna_functions</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">class</span> <span class="nc">Gene</span><span class="p">:</span>
    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">chars_per_line</span><span class="o">=</span><span class="mi">70</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write DNA sequence to file with name filename.&quot;&quot;&quot;</span>
        <span class="n">tofile_with_line_sep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dna</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">chars_per_line</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return no of occurrences of base in DNA.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dna</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_base_frequencies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return dict of base frequencies in DNA.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">get_base_frequencies</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dna</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">format_base_frequencies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return base frequencies formatted with two decimals.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">format_frequencies</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_base_frequencies</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="section" id="flexible-constructor">
<h3>Flexible Constructor<a class="headerlink" href="#flexible-constructor" title="Permalink to this headline">¶</a></h3>
<p>The constructor can be made more flexible. First, the exon regions
may not be known so we should allow <tt class="docutils literal"><span class="pre">None</span></tt> as value and in fact
use that as default value. Second, exon regions at the start and/or
end of the DNA string will lead to empty intron <tt class="docutils literal"><span class="pre">Region</span></tt> objects so a proper
test on nonzero length of the introns must be inserted.
Third, the data for the DNA string and
the exon regions can either be passed as arguments or downloaded and read
from file.
Two different initializations of <tt class="docutils literal"><span class="pre">Gene</span></tt> objects are therefore</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">g1</span> <span class="o">=</span> <span class="n">Gene</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="n">exon_regions</span><span class="p">)</span>  <span class="c"># user has read data from file</span>
<span class="n">g2</span> <span class="o">=</span> <span class="n">Gene</span><span class="p">((</span><span class="n">urlbase</span><span class="p">,</span> <span class="n">dna_file</span><span class="p">),</span> <span class="p">(</span><span class="n">urlbase</span><span class="p">,</span> <span class="n">exon_file</span><span class="p">))</span>  <span class="c"># download</span>
</pre></div>
</div>
<p>One can pass <tt class="docutils literal"><span class="pre">None</span></tt> for <tt class="docutils literal"><span class="pre">urlbase</span></tt> if the files are already at the
computer. The flexible constructor has, not surprisingly, much longer code
than the first version. The implementation illustrates well how the concept of
overloaded constructors in other languages, like C++ and Java, are
dealt with in Python (overloaded constructors take different types
of arguments to initialize an instance):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Gene</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dna</span><span class="p">,</span> <span class="n">exon_regions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        dna: string or (urlbase,filename) tuple</span>
<span class="sd">        exon_regions: None, list of (start,end) tuples</span>
<span class="sd">                      or (urlbase,filename) tuple</span>
<span class="sd">        In case of (urlbase,filename) tuple the file</span>
<span class="sd">        is downloaded and read.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> \
           <span class="nb">len</span><span class="p">(</span><span class="n">dna</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dna</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> \
           <span class="nb">isinstance</span><span class="p">(</span><span class="n">dna</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">download</span><span class="p">(</span><span class="n">urlbase</span><span class="o">=</span><span class="n">dna</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">filename</span><span class="o">=</span><span class="n">dna</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">dna</span> <span class="o">=</span> <span class="n">read_dnafile</span><span class="p">(</span><span class="n">dna</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">pass</span> <span class="c"># ok type (the other possibility)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s">&#39;dna=</span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s"> is not string or (urlbase,filename) &#39;</span>\
                <span class="s">&#39;tuple&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">dna</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_dna</span> <span class="o">=</span> <span class="n">dna</span>

        <span class="n">er</span> <span class="o">=</span> <span class="n">exon_regions</span>
        <span class="k">if</span> <span class="n">er</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_exons</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_introns</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">er</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> \
                <span class="nb">len</span><span class="p">(</span><span class="n">er</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">er</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">er</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">download</span><span class="p">(</span><span class="n">urlbase</span><span class="o">=</span><span class="n">er</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">filename</span><span class="o">=</span><span class="n">er</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">exon_regions</span> <span class="o">=</span> <span class="n">read_exon_regions</span><span class="p">(</span><span class="n">er</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">er</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> \
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">er</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> \
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">er</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">er</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">pass</span> <span class="c"># ok type (the other possibility)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s">&#39;exon_regions=</span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s"> is not list of (int,int) &#39;</span>
                    <span class="s">&#39;or (urlbase,filename) tuple&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">er</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">era</span><span class="p">)))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_exon_regions</span> <span class="o">=</span> <span class="n">exon_regions</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_exons</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">exon_regions</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_exons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Region</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>

            <span class="c"># Compute the introns (regions between the exons)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_introns</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">prev_end</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">exon_regions</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">start</span> <span class="o">-</span> <span class="n">prev_end</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_introns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">Region</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="n">prev_end</span><span class="p">,</span> <span class="n">start</span><span class="p">))</span>
                <span class="n">prev_end</span> <span class="o">=</span> <span class="n">end</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dna</span><span class="p">)</span> <span class="o">-</span> <span class="n">end</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_introns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Region</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dna</span><span class="p">)))</span>
</pre></div>
</div>
<p>Note that we perform quite detailed testing of the object type
of the data structures supplied as the <tt class="docutils literal"><span class="pre">dna</span></tt> and <tt class="docutils literal"><span class="pre">exon_regions</span></tt>
arguments. This can well be done to ensure safe use also when there is only
one allowed type per argument.</p>
</div>
<div class="section" id="other-methods">
<h3>Other Methods<a class="headerlink" href="#other-methods" title="Permalink to this headline">¶</a></h3>
<p>A <tt class="docutils literal"><span class="pre">create_mRNA</span></tt> method, returning the mRNA as a string, can be coded as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">create_mRNA</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return string for mRNA.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exons</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">create_mRNA</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dna</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exon_regions</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s">&#39;Cannot create mRNA for gene with no exon regions&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Also here we rely on calling an already implemented function, but include
some testing whether asking for mRNA is appropriate.</p>
<p>Methods for creating a mutated gene are also included:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">mutate_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return Gene with a mutation to base at position pos.&quot;&quot;&quot;</span>
    <span class="n">dna</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dna</span><span class="p">[:</span><span class="n">pos</span><span class="p">]</span> <span class="o">+</span> <span class="n">base</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dna</span><span class="p">[</span><span class="n">pos</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">Gene</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exon_regions</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">mutate_random</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return Gene with n mutations at a random position.</span>
<span class="sd">    All mutations are equally probable.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mutated_dna</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dna</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">mutated_dna</span> <span class="o">=</span> <span class="n">mutate</span><span class="p">(</span><span class="n">mutated_dna</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Gene</span><span class="p">(</span><span class="n">mutated_dna</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exon_regions</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">mutate_via_markov_chain</span><span class="p">(</span><span class="n">markov_chain</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return Gene with a mutation at a random position.</span>
<span class="sd">    Mutation into new base based on transition</span>
<span class="sd">    probabilities in the markov_chain dict of dicts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mutated_dna</span> <span class="o">=</span> <span class="n">mutate_via_markov_chain</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dna</span><span class="p">,</span> <span class="n">markov_chain</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Gene</span><span class="p">(</span><span class="n">mutated_dna</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exon_regions</span><span class="p">)</span>
</pre></div>
</div>
<p>Some &#8220;get&#8221; methods that give access to the fundamental attributes
of the class can be included:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">get_dna</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dna</span>

<span class="k">def</span> <span class="nf">get_exons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exons</span>

<span class="k">def</span> <span class="nf">get_introns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_introns</span>
</pre></div>
</div>
<p>Alternatively, one could access the attributes directly: <tt class="docutils literal"><span class="pre">gene._dna</span></tt>,
<tt class="docutils literal"><span class="pre">gene._exons</span></tt>, etc. In that case we should remove the leading underscore as
this underscore signals that these
attributes are considered &#8220;protected&#8221;, i.e., not to be directly accessed
by the user. The &#8220;protection&#8221; in &#8220;get&#8221; functions is more mental
than actual since we anyway give the data structures in the hands of
the user and she can do whatever she wants (even delete them).</p>
<p>Special methods for the length of a gene, adding genes, checking if
two genes are identical, and printing of compact gene information
are relevant to add:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dna</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;self + other: append other to self (DNA string).&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exons</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">_exons</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Gene</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dna</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">_dna</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s">&#39;cannot do Gene + Gene with exon regions&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;self += other: append other to self (DNA string).&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exons</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">_exons</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dna</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">_dna</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s">&#39;cannot do Gene += Gene with exon regions&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check if two Gene instances are equal.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dna</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_dna</span> <span class="ow">and</span> \
           <span class="bp">self</span><span class="o">.</span><span class="n">_exons</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_exons</span>

<span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Pretty print (condensed info).&quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s">&#39;Gene: &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dna</span><span class="p">[:</span><span class="mi">6</span><span class="p">]</span> <span class="o">+</span> <span class="s">&#39;...&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dna</span><span class="p">[</span><span class="o">-</span><span class="mi">6</span><span class="p">:]</span> <span class="o">+</span> \
        <span class="s">&#39;, length=</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dna</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exons</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;, </span><span class="si">%d</span><span class="s"> exon regions&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_exons</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">s</span>
</pre></div>
</div>
<p>Here is an interactive session demonstrating how we can work with
class <tt class="docutils literal"><span class="pre">Gene</span></tt> objects:</p>
<div class="highlight-text"><div class="highlight"><pre>&gt;&gt;&gt; from dna_classes import Gene
&gt;&gt;&gt; g1 = Gene(&#39;ATCCGTAATTGCGCA&#39;, [(2,4), (6,9)])
&gt;&gt;&gt; print g1
Gene: ATCCGT...TGCGCA, length=15, 2 exon regions
&gt;&gt;&gt; g2 = g1.mutate_random(10)
&gt;&gt;&gt; print g2
Gene: ATCCGT...TGTGCT, length=15, 2 exon regions
&gt;&gt;&gt; g1 == g2
False
&gt;&gt;&gt; g1 += g2  # expect exception
Traceback (most recent call last):
...
ValueError: cannot do Gene += Gene with exon regions
&gt;&gt;&gt; g1b = Gene(g1.get_dna(), None)
&gt;&gt;&gt; g2b = Gene(g2.get_dna(), None)
&gt;&gt;&gt; print g1b
Gene: ATCCGT...TGCGCA, length=15
&gt;&gt;&gt; g3 = g1b + g2b
&gt;&gt;&gt; g3.format_base_frequencies()
&#39;A: 0.17, C: 0.23, T: 0.33, G: 0.27&#39;
</pre></div>
</div>
</div>
</div>
<div class="section" id="subclasses">
<h2>Subclasses<a class="headerlink" href="#subclasses" title="Permalink to this headline">¶</a></h2>
<p>There are two fundamental types of genes: the most common type that
codes for proteins (indirectly via mRNA) and the type that only codes
for RNA (without being further processed to proteins).
The product of a gene, mRNA or protein, depends on the type of gene we have.
It is then natural to create two subclasses for the two types of
gene and have a method <tt class="docutils literal"><span class="pre">get_product</span></tt> which returns the product
of that type of gene.</p>
<p>The <tt class="docutils literal"><span class="pre">get_product</span></tt> method can be declared in class <tt class="docutils literal"><span class="pre">Gene</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">get_product</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
        <span class="s">&#39;Subclass </span><span class="si">%s</span><span class="s"> must implement get_product&#39;</span> <span class="o">%</span> \
        <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
</pre></div>
</div>
<p>The exception here will be triggered by an instance (<tt class="docutils literal"><span class="pre">self</span></tt>)
of any subclass that just inherits <tt class="docutils literal"><span class="pre">get_product</span></tt> from class <tt class="docutils literal"><span class="pre">Gene</span></tt>
without implementing a subclass version of this method.</p>
<p>The two subclasses of <tt class="docutils literal"><span class="pre">Gene</span></tt> may take this simple form:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">RNACodingGene</span><span class="p">(</span><span class="n">Gene</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get_product</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_mRNA</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">ProteinCodingGene</span><span class="p">(</span><span class="n">Gene</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dna</span><span class="p">,</span> <span class="n">exon_positions</span><span class="p">):</span>
        <span class="n">Gene</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dna</span><span class="p">,</span> <span class="n">exon_positions</span><span class="p">)</span>
        <span class="n">urlbase</span> <span class="o">=</span> <span class="s">&#39;http://hplgit.github.com/bioinf-py/data/&#39;</span>
        <span class="n">genetic_code_file</span> <span class="o">=</span> <span class="s">&#39;genetic_code.tsv&#39;</span>
        <span class="n">download</span><span class="p">(</span><span class="n">urlbase</span><span class="p">,</span> <span class="n">genetic_code_file</span><span class="p">)</span>
        <span class="n">code</span> <span class="o">=</span> <span class="n">read_genetic_code</span><span class="p">(</span><span class="n">genetic_code_file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">genetic_code</span> <span class="o">=</span> <span class="n">code</span>

    <span class="k">def</span> <span class="nf">get_product</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">create_protein_fixed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">create_mRNA</span><span class="p">(),</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">genetic_code</span><span class="p">)</span>
</pre></div>
</div>
<p>A demonstration of how to load the lactase gene and create the
lactase protein is done with</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_lactase_gene</span><span class="p">():</span>
    <span class="n">urlbase</span> <span class="o">=</span> <span class="s">&#39;http://hplgit.github.com/bioinf-py/data/&#39;</span>
    <span class="n">lactase_gene_file</span> <span class="o">=</span> <span class="s">&#39;lactase_gene.txt&#39;</span>
    <span class="n">lactase_exon_file</span> <span class="o">=</span> <span class="s">&#39;lactase_exon.tsv&#39;</span>
    <span class="n">lactase_gene</span> <span class="o">=</span> <span class="n">ProteinCodingGene</span><span class="p">(</span>
        <span class="p">(</span><span class="n">urlbase</span><span class="p">,</span> <span class="n">lactase_gene_file</span><span class="p">),</span>
        <span class="p">(</span><span class="n">urlbase</span><span class="p">,</span> <span class="n">lactase_exon_file</span><span class="p">))</span>

    <span class="n">protein</span> <span class="o">=</span> <span class="n">lactase_gene</span><span class="o">.</span><span class="n">get_product</span><span class="p">()</span>
    <span class="n">tofile_with_line_sep</span><span class="p">(</span><span class="n">protein</span><span class="p">,</span> <span class="s">&#39;output&#39;</span><span class="p">,</span> <span class="s">&#39;lactase_protein.txt&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, envision that the Lactase gene would instead have been an
RNA-coding gene. The only necessary changes would have been to exchange
<tt class="docutils literal"><span class="pre">ProteinCodingGene</span></tt> by <tt class="docutils literal"><span class="pre">RNACodingGene</span></tt> in the assignment to
<tt class="docutils literal"><span class="pre">lactase_gene</span></tt>, and one would get out a final RNA product instead of a
protein.</p>
<p><strong>Acknowledgments.</strong>
The authors want to thank Sveinung Gundersen, Ksenia Khelik, Halfdan Rydbeck,
and Kai Trengereid for contributing to the examples and their implementations.</p>
</div>
</div>
<div class="section" id="exercises">
<h1>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h1>
<div class="section" id="exercise-1-find-pairs-of-characters">
<span id="bioinf-exer-pairs1"></span><h2>Exercise 1: Find pairs of characters<a class="headerlink" href="#exercise-1-find-pairs-of-characters" title="Permalink to this headline">¶</a></h2>
<p>Write a function <tt class="docutils literal"><span class="pre">count_pairs(dna,</span> <span class="pre">pair)</span></tt> that returns the number of
occurrences of a pair of characters (<tt class="docutils literal"><span class="pre">pair</span></tt>) in a DNA string (<tt class="docutils literal"><span class="pre">dna</span></tt>).
For example, calling the function with <tt class="docutils literal"><span class="pre">dna</span></tt> as <tt class="docutils literal"><span class="pre">'ACTGCTATCCATT'</span></tt>
and <tt class="docutils literal"><span class="pre">pair</span></tt> as  <tt class="docutils literal"><span class="pre">'AT'</span></tt> will return 2.
Filename: <tt class="docutils literal"><span class="pre">count_pairs.py</span></tt>.</p>
</div>
<div class="section" id="exercise-2-count-substrings">
<span id="bioinf-exer-substr1"></span><h2>Exercise 2: Count substrings<a class="headerlink" href="#exercise-2-count-substrings" title="Permalink to this headline">¶</a></h2>
<p>This is an extension of <a class="reference internal" href="#bioinf-exer-pairs1"><em>Exercise 1: Find pairs of characters</em></a>:
count how many times a certain string appears in another string.
For example, the function returns 3 when called
with the DNA string <tt class="docutils literal"><span class="pre">'ACGTTACGGAACG'</span></tt>
and the substring <tt class="docutils literal"><span class="pre">'ACG'</span></tt>.</p>
<p><strong>Hint.</strong>
For each match of the first character of the
substring in the main string, check if the next <tt class="docutils literal"><span class="pre">n</span></tt> characters
in the main string matches the substring, where <tt class="docutils literal"><span class="pre">n</span></tt> is the length
of the substring. Use slices like <tt class="docutils literal"><span class="pre">s[3:9]</span></tt> to pick out a substring of <tt class="docutils literal"><span class="pre">s</span></tt>.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">count_substr.py</span></tt>.</p>
</div>
<div class="section" id="exercise-3-allow-different-types-for-a-function-argument">
<span id="bioinf-exer-freq-fargs"></span><h2>Exercise 3: Allow different types for a function argument<a class="headerlink" href="#exercise-3-allow-different-types-for-a-function-argument" title="Permalink to this headline">¶</a></h2>
<p>Consider the family of <tt class="docutils literal"><span class="pre">find_consensus_v*</span></tt> functions from
the section <a class="reference internal" href="#bioinf-freq-analysis"><em>Analyzing the Frequency Matrix</em></a>. The different versions work on
different representations of the frequency matrix. Make a unified
<tt class="docutils literal"><span class="pre">find_consensus</span></tt> function that accepts different data structures
for the <tt class="docutils literal"><span class="pre">frequency_matrix</span></tt>. Test on the type of data structure and
perform the necessary actions.
Filename: <tt class="docutils literal"><span class="pre">find_consensus.py</span></tt>.</p>
</div>
<div class="section" id="exercise-4-make-a-function-more-robust">
<span id="bioinf-exer-get-base-counts2"></span><h2>Exercise 4: Make a function more robust<a class="headerlink" href="#exercise-4-make-a-function-more-robust" title="Permalink to this headline">¶</a></h2>
<p>Consider the function <tt class="docutils literal"><span class="pre">get_base_counts(dna)</span></tt>
from the section <a class="reference internal" href="#bioinf-basefreq"><em>Finding Base Frequencies</em></a>,
which counts how many times <tt class="docutils literal"><span class="pre">A</span></tt>, <tt class="docutils literal"><span class="pre">C</span></tt>, <tt class="docutils literal"><span class="pre">G</span></tt>, and
<tt class="docutils literal"><span class="pre">T</span></tt> appears in the string <tt class="docutils literal"><span class="pre">dna</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">get_base_counts</span><span class="p">(</span><span class="n">dna</span><span class="p">):</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;T&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;G&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">dna</span><span class="p">:</span>
        <span class="n">counts</span><span class="p">[</span><span class="n">base</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">counts</span>
</pre></div>
</div>
<p>Unfortunately, this function crashes if other letters appear in <tt class="docutils literal"><span class="pre">dna</span></tt>.
Write an enhanced function <tt class="docutils literal"><span class="pre">get_base_counts2</span></tt> which solves this problem.
Test it on a string like <tt class="docutils literal"><span class="pre">'ADLSTTLLD'</span></tt>.
Filename: <tt class="docutils literal"><span class="pre">get_base_counts2.py</span></tt>.</p>
</div>
<div class="section" id="exercise-5-find-proportion-of-bases-inside-outside-exons">
<span id="bioinf-exer-ainsouts-exons"></span><h2>Exercise 5: Find proportion of bases inside/outside exons<a class="headerlink" href="#exercise-5-find-proportion-of-bases-inside-outside-exons" title="Permalink to this headline">¶</a></h2>
<p>Consider the lactase gene as described in
the sections <a class="reference internal" href="#bioinf-gene2protein"><em>Translating Genes into Proteins</em></a> and <a class="reference internal" href="#bioinf-lactase-milk"><em>Some Humans Can Drink Milk, While Others Cannot</em></a>.
What is the proportion of base A inside and outside exons of
the lactase gene?</p>
<p><strong>Hint.</strong>
Write a function <tt class="docutils literal"><span class="pre">get_exons</span></tt>, which returns
all the substrings of the exon regions concatenated.
Also write a function <tt class="docutils literal"><span class="pre">get_introns</span></tt>, which
returns all the substrings between the exon regions concatenated.
The function <tt class="docutils literal"><span class="pre">get_base_frequencies</span></tt> from the section <a class="reference internal" href="#bioinf-basefreq"><em>Finding Base Frequencies</em></a>
can then be used to analyze the frequencies of bases A, C, G, and T
in the two strings.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">prop_A_exons.py</span></tt>.</p>
</div>
<div class="section" id="exercise-6-speed-up-markov-chain-mutation">
<span id="bioinf-exer-markov-chain-eff"></span><h2>Exercise 6: Speed up Markov chain mutation<a class="headerlink" href="#exercise-6-speed-up-markov-chain-mutation" title="Permalink to this headline">¶</a></h2>
<p>The functions <tt class="docutils literal"><span class="pre">transition</span></tt> and <tt class="docutils literal"><span class="pre">mutate_via_markov_chain</span></tt> from the section <a class="reference internal" href="#bioinf-random"><em>Random Mutations of Genes</em></a> were made for being easy to read and understand.  Upon
closer inspection, we realize that the <tt class="docutils literal"><span class="pre">transition</span></tt> function
constructs the <tt class="docutils literal"><span class="pre">interval_limits</span></tt> every time a random transition is to
be computed, and we want to run a large number of transitions.  By
merging the two functions, pre-computing interval limits for each
<tt class="docutils literal"><span class="pre">from_base</span></tt>, and adding a loop over <tt class="docutils literal"><span class="pre">N</span></tt> mutations, one can
reduce the computation of interval limits to a minimum. Perform such
an efficiency enhancement.  Measure the CPU time of this new function
versus the <tt class="docutils literal"><span class="pre">mutate_via_markov_chain</span></tt> function for 1 million mutations.
Filename: <tt class="docutils literal"><span class="pre">markov_chain_mutation2.py</span></tt>.</p>
</div>
<div class="section" id="exercise-7-extend-the-constructor-in-class-gene">
<span id="bioinf-exer-gene-randominit"></span><h2>Exercise 7: Extend the constructor in class Gene<a class="headerlink" href="#exercise-7-extend-the-constructor-in-class-gene" title="Permalink to this headline">¶</a></h2>
<p>Modify the constructor in class <tt class="docutils literal"><span class="pre">Gene</span></tt> from the section <a class="reference internal" href="#bioinf-oo"><em>Classes for DNA Analysis</em></a> such
that giving no arguments to the constructor makes the class call
up the <tt class="docutils literal"><span class="pre">generate_string</span></tt> method (from the <tt class="docutils literal"><span class="pre">dna_functions</span></tt> module)
which generates a random DNA sequence.
Filename: <tt class="docutils literal"><span class="pre">dna_classes2.py</span></tt>.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Illustrating Python via Bioinformatics Examples</a></li>
<li><a class="reference internal" href="#basic-bioinformatics-examples-in-python">Basic Bioinformatics Examples in Python</a><ul>
<li><a class="reference internal" href="#counting-letters-in-dna-strings">Counting Letters in DNA Strings</a><ul>
<li><a class="reference internal" href="#list-iteration">List Iteration</a></li>
<li><a class="reference internal" href="#string-iteration">String Iteration</a></li>
<li><a class="reference internal" href="#program-flow">Program Flow</a></li>
<li><a class="reference internal" href="#index-iteration">Index Iteration</a></li>
<li><a class="reference internal" href="#while-loops">While Loops</a></li>
<li><a class="reference internal" href="#summing-a-boolean-list">Summing a Boolean List</a></li>
<li><a class="reference internal" href="#inline-if-test">Inline If Test</a></li>
<li><a class="reference internal" href="#using-boolean-values-directly">Using Boolean Values Directly</a></li>
<li><a class="reference internal" href="#list-comprehensions">List Comprehensions</a></li>
<li><a class="reference internal" href="#using-a-sum-iterator">Using a Sum Iterator</a></li>
<li><a class="reference internal" href="#extracting-indices">Extracting Indices</a></li>
<li><a class="reference internal" href="#using-python-s-library">Using Python&#8217;s Library</a></li>
</ul>
</li>
<li><a class="reference internal" href="#efficiency-assessment">Efficiency Assessment</a><ul>
<li><a class="reference internal" href="#generating-random-dna-strings">Generating Random DNA Strings</a></li>
<li><a class="reference internal" href="#measuring-cpu-time">Measuring CPU Time</a></li>
</ul>
</li>
<li><a class="reference internal" href="#verifying-the-implementations">Verifying the implementations</a></li>
<li><a class="reference internal" href="#computing-frequencies">Computing Frequencies</a><ul>
<li><a class="reference internal" href="#separate-frequency-lists">Separate Frequency Lists</a></li>
<li><a class="reference internal" href="#nested-list">Nested List</a></li>
<li><a class="reference internal" href="#dictionary-for-more-convenient-indexing">Dictionary for More Convenient Indexing</a></li>
<li><a class="reference internal" href="#numerical-python-array">Numerical Python Array</a></li>
<li><a class="reference internal" href="#dictionary-of-lists">Dictionary of Lists</a></li>
<li><a class="reference internal" href="#dictionary-of-dictionaries">Dictionary of Dictionaries</a></li>
<li><a class="reference internal" href="#using-dictionaries-with-default-values">Using Dictionaries with Default Values</a></li>
<li><a class="reference internal" href="#using-arrays-and-vectorization">Using Arrays and Vectorization</a></li>
</ul>
</li>
<li><a class="reference internal" href="#analyzing-the-frequency-matrix">Analyzing the Frequency Matrix</a><ul>
<li><a class="reference internal" href="#list-of-lists-frequency-matrix">List of Lists Frequency Matrix</a></li>
<li><a class="reference internal" href="#dict-of-dicts-frequency-matrix">Dict of Dicts Frequency Matrix</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dot-plots-from-pair-of-dna-sequences">Dot Plots from Pair of DNA Sequences</a><ul>
<li><a class="reference internal" href="#using-lists-of-lists">Using Lists of Lists</a></li>
<li><a class="reference internal" href="#using-numerical-python-arrays">Using Numerical Python Arrays</a></li>
</ul>
</li>
<li><a class="reference internal" href="#finding-base-frequencies">Finding Base Frequencies</a></li>
<li><a class="reference internal" href="#translating-genes-into-proteins">Translating Genes into Proteins</a></li>
<li><a class="reference internal" href="#some-humans-can-drink-milk-while-others-cannot">Some Humans Can Drink Milk, While Others Cannot</a></li>
<li><a class="reference internal" href="#random-mutations-of-genes">Random Mutations of Genes</a><ul>
<li><a class="reference internal" href="#a-simple-mutation-model">A Simple Mutation Model</a></li>
<li><a class="reference internal" href="#vectorized-version">Vectorized Version</a></li>
<li><a class="reference internal" href="#a-markov-chain-mutation-model">A Markov Chain Mutation Model</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#classes-for-dna-analysis">Classes for DNA Analysis</a><ul>
<li><a class="reference internal" href="#class-for-regions">Class for Regions</a></li>
<li><a class="reference internal" href="#class-for-genes">Class for Genes</a><ul>
<li><a class="reference internal" href="#basic-features-of-class-gene">Basic Features of class Gene</a></li>
<li><a class="reference internal" href="#flexible-constructor">Flexible Constructor</a></li>
<li><a class="reference internal" href="#other-methods">Other Methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#subclasses">Subclasses</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercises">Exercises</a><ul>
<li><a class="reference internal" href="#exercise-1-find-pairs-of-characters">Exercise 1: Find pairs of characters</a></li>
<li><a class="reference internal" href="#exercise-2-count-substrings">Exercise 2: Count substrings</a></li>
<li><a class="reference internal" href="#exercise-3-allow-different-types-for-a-function-argument">Exercise 3: Allow different types for a function argument</a></li>
<li><a class="reference internal" href="#exercise-4-make-a-function-more-robust">Exercise 4: Make a function more robust</a></li>
<li><a class="reference internal" href="#exercise-5-find-proportion-of-bases-inside-outside-exons">Exercise 5: Find proportion of bases inside/outside exons</a></li>
<li><a class="reference internal" href="#exercise-6-speed-up-markov-chain-mutation">Exercise 6: Speed up Markov chain mutation</a></li>
<li><a class="reference internal" href="#exercise-7-extend-the-constructor-in-class-gene">Exercise 7: Extend the constructor in class Gene</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">Illustrating Python via Examples from Bioinformatics</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/main_bioinf.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="index.html" title="Illustrating Python via Examples from Bioinformatics"
             >previous</a> |</li>
        <li><a href="index.html">Illustrating Python via Examples from Bioinformatics</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
  <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
  </div>
</div>

  </body>
</html>